{"version":3,"sources":["p5.play.js"],"names":["root","factory","define","amd","p5","defineLazyP5Property","name","getter","Object","defineProperty","prototype","configurable","enumerable","get","context","_isGlobal","window","_p5PlayProperties","call","boundConstructorFactory","constructor","Error","pInst","F","args","Array","slice","arguments","apply","concat","createPInstBinder","methodName","method","bind","registerMethod","camera","Camera","init","abs","radians","dist","degrees","pow","round","Group","spriteUpdate","createSprite","x","y","width","height","s","Sprite","depth","allSprites","maxDepth","add","removeSprite","sprite","remove","updateSprites","upd","i","size","update","getSprites","length","toArray","arr","j","isTagged","push","drawSprites","group","draw","drawSprite","display","loadAnimation","construct","Animation","loadSpriteSheet","SpriteSheet","animation","anim","keyStates","mouseStates","_x","_y","_w","_h","pInstBind","createVector","color","random","print","pop","colorMode","noStroke","rectMode","ellipseMode","imageMode","translate","scale","rotate","stroke","strokeWeight","line","noFill","fill","textAlign","textSize","text","rect","cos","sin","atan2","quadTree","RGB","CENTER","LEFT","BOTTOM","position","previousPosition","newPosition","deltaX","deltaY","velocity","maxSpeed","friction","collider","undefined","colliderType","touching","left","right","top","bottom","mass","immovable","restitution","_rotation","set","value","rotateToDirection","setSpeed","getSpeed","rotationSpeed","dirX","dirY","visible","mouseActive","mouseIsOver","mouseIsPressed","_internalWidth","_internalHeight","originalWidth","originalHeight","removed","life","debug","shapeColor","groups","animations","currentAnimation","_syncAnimationSizes","getWidth","getHeight","getBoundingBox","_getScaleX","_getScaleY","frameChanged","limitSpeed","mag","getDirection","rotation","t","AABB","_angleMode","RADIANS","extents","originalExtents","CircleCollider","radius","originalRadius","setDefaultCollider","mouseUpdate","onMouseOver","onMouseOut","onMousePressed","onMouseReleased","insert","mouseWasOver","mousePosition","mouseWasPressed","active","mouseX","mouseY","center","setCollider","type","offsetX","offsetY","TypeError","_warn","v","Math","floor","max","w","h","mirrorX","dir","mirrorY","removeObject","setVelocity","direction","isNaN","addToGroup","speed","k","angle","a","addSpeed","attractionPoint","magnitude","pointX","pointY","addImage","Image","addAnimation","label","sourceAnimation","newAnimation","clone","isSpriteAnimation","animFrames","changeImage","changeAnimation","getAnimationLabel","overlapPixel","point","img","getFrameImage","overlapPoint","sqRadius","sqDist","overlap","target","callback","AABBops","collide","displace","bounce","result","others","retrieveFromGroup","displacement","other","tunnelX","tunnelY","c","e","offset","mult","newVelX1","newVelY1","newVelX2","newVelY2","sub","dx1","Vector","dx2","magSq","totalMass","m1","m2","newVel1","dot","newVel2","zoom","on","cameraPush","off","cameraPop","_center","_radius","_offset","ellipse","r","thisCenterX","thisCenterY","otherCenterX","otherCenterY","radii","intersection","_extents","PI","copy","min","w2","h2","md","minkowskiDifference","pt","distance","closestPointOnBoundsToPoint","xOverlap","yOverlap","d","topLeft","fullSize","div","minDist","boundsPoint","frameArguments","images","frame","cycles","targetFrame","offX","offY","frameDelay","playing","looping","imageCollider","from","to","substring","digits1","digits2","charAt","prefix1","fileName","prefix2","number1","parseInt","number2","loadImage","nf","spriteSheet","frames","myClone","xpos","ypos","frame_info","image","previousFrame","play","stop","rewind","changeFrame","f","nextFrame","goToFrame","toFrame","getFrame","getLastFrame","getImageAt","spriteSheetArgs","frame_width","frame_height","num_frames","_generateSheetFrames","sX","sY","isArray","drawFrame","frame_name","frameToDraw","dWidth","dHeight","cloneFrame","Quadtree","bounds","max_objects","max_levels","level","objects","object_refs","nodes","keyWentDown","key","_isKeyInState","keyWentUp","keyDown","state","keyCode","_p5play","_keyCodeFromAlias","keyIsDown","mouseDown","buttonCode","_isMouseButtonInState","mouseUp","mouseWentUp","mouseWentDown","mouseButton","KEY","KEY_DEPRECATIONS","alias","toUpperCase","readPresses","btn","useQuadTree","use","array","_groupCollide","didCollide","contains","indexOf","item","len","virtEquals","obj","equals","Function","removeSprites","clear","splice","reduce","minDepth","Infinity","sort","b","updateBounds","getAll","split","nextLevel","subWidth","subHeight","getIndex","pRect","index","verticalMidpoint","horizontalMidpoint","topQuadrant","bottomQuadrant","retrieve","returnObjects","results","candidates","getObjectNode","node","cleanup","updateTree","message","console","warn","log"],"mappings":"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","file":"p5.play.fa39aca3.js","sourceRoot":"../src","sourcesContent":["/*\np5.play\nby Paolo Pedercini/molleindustria, 2015\nhttp://molleindustria.org/\n*/\n\n(function(root, factory) {\nif (typeof define === 'function' && define.amd)\ndefine('p5.play', ['p5'], function(p5) { (factory(p5)); });\n//else if (typeof exports === 'object')\n//factory(require('../p5'));\nelse\nfactory(root.p5);\n}(this, function(p5) {\n/**\n * p5.play is a library for p5.js to facilitate the creation of games and gamelike\n * projects.\n *\n * It provides a flexible Sprite class to manage visual objects in 2D space\n * and features such as animation support, basic collision detection\n * and resolution, mouse and keyboard interactions, and a virtual camera.\n *\n * p5.play is not a box2D-derived physics engine, it doesn't use events, and it's\n * designed to be understood and possibly modified by intermediate programmers.\n *\n * See the examples folder for more info on how to use this library.\n *\n * @module p5.play\n * @submodule p5.play\n * @for p5.play\n * @main\n */\n\n// =============================================================================\n//                         initialization\n// =============================================================================\n\n// This is the new way to initialize custom p5 properties for any p5 instance.\n// The goal is to migrate lazy P5 properties over to this method.\n// @see https://github.com/molleindustria/p5.play/issues/46\np5.prototype.registerMethod('init', function p5PlayInit() {\n  /**\n   * The sketch camera automatically created at the beginning of a sketch.\n   * A camera facilitates scrolling and zooming for scenes extending beyond\n   * the canvas. A camera has a position, a zoom factor, and the mouse\n   * coordinates relative to the view.\n   *\n   * In p5.js terms the camera wraps the whole drawing cycle in a\n   * transformation matrix but it can be disabled anytime during the draw\n   * cycle, for example to draw interface elements in an absolute position.\n   *\n   * @property camera\n   * @type {camera}\n   */\n  this.camera = new Camera(this, 0, 0, 1);\n  this.camera.init = false;\n});\n\n// This provides a way for us to lazily define properties that\n// are global to p5 instances.\n//\n// Note that this isn't just an optimization: p5 currently provides no\n// way for add-ons to be notified when new p5 instances are created, so\n// lazily creating these properties is the *only* mechanism available\n// to us. For more information, see:\n//\n// https://github.com/processing/p5.js/issues/1263\nfunction defineLazyP5Property(name, getter) {\n  Object.defineProperty(p5.prototype, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var context = (this instanceof p5 && !this._isGlobal) ? this : window;\n\n      if (typeof(context._p5PlayProperties) === 'undefined') {\n        context._p5PlayProperties = {};\n      }\n      if (!(name in context._p5PlayProperties)) {\n        context._p5PlayProperties[name] = getter.call(context);\n      }\n      return context._p5PlayProperties[name];\n    }\n  });\n}\n\n// This returns a factory function, suitable for passing to\n// defineLazyP5Property, that returns a subclass of the given\n// constructor that is always bound to a particular p5 instance.\nfunction boundConstructorFactory(constructor) {\n  if (typeof(constructor) !== 'function')\n    throw new Error('constructor must be a function');\n\n  return function createBoundConstructor() {\n    var pInst = this;\n\n    function F() {\n      var args = Array.prototype.slice.call(arguments);\n\n      return constructor.apply(this, [pInst].concat(args));\n    }\n    F.prototype = constructor.prototype;\n\n    return F;\n  };\n}\n\n// This is a utility that makes it easy to define convenient aliases to\n// pre-bound p5 instance methods.\n//\n// For example:\n//\n//   var pInstBind = createPInstBinder(pInst);\n//\n//   var createVector = pInstBind('createVector');\n//   var loadImage = pInstBind('loadImage');\n//\n// The above will create functions createVector and loadImage, which can be\n// used similar to p5 global mode--however, they're bound to specific p5\n// instances, and can thus be used outside of global mode.\nfunction createPInstBinder(pInst) {\n  return function pInstBind(methodName) {\n    var method = pInst[methodName];\n\n    if (typeof(method) !== 'function')\n      throw new Error('\"' + methodName + '\" is not a p5 method');\n    return method.bind(pInst);\n  };\n}\n\n// These are utility p5 functions that don't depend on p5 instance state in\n// order to work properly, so we'll go ahead and make them easy to\n// access without needing to bind them to a p5 instance.\nvar abs = p5.prototype.abs;\nvar radians = p5.prototype.radians;\nvar dist = p5.prototype.dist;\nvar degrees = p5.prototype.degrees;\nvar pow = p5.prototype.pow;\nvar round = p5.prototype.round;\n\n\n// =============================================================================\n//                         p5 additions\n// =============================================================================\n\n/**\n* A Group containing all the sprites in the sketch.\n*\n* @property allSprites\n* @type {Group}\n*/\n\ndefineLazyP5Property('allSprites', function() {\n  return new p5.prototype.Group();\n});\n\np5.prototype.spriteUpdate = true;\n\n/**\n   * A Sprite is the main building block of p5.play:\n   * an element able to store images or animations with a set of\n   * properties such as position and visibility.\n   * A Sprite can have a collider that defines the active area to detect\n   * collisions or overlappings with other sprites and mouse interactions.\n   *\n   * Sprites created using createSprite (the preferred way) are added to the\n   * allSprites group and given a depth value that puts it in front of all\n   * other sprites.\n   *\n   * @method createSprite\n   * @param {Number} x Initial x coordinate\n   * @param {Number} y Initial y coordinate\n   * @param {Number} width Width of the placeholder rectangle and of the\n   *                       collider until an image or new collider are set\n   * @param {Number} height Height of the placeholder rectangle and of the\n   *                       collider until an image or new collider are set\n   * @return {Object} The new sprite instance\n   */\n\np5.prototype.createSprite = function(x, y, width, height) {\n  var s = new Sprite(this, x, y, width, height);\n  s.depth = this.allSprites.maxDepth()+1;\n  this.allSprites.add(s);\n  return s;\n};\n\n\n/**\n   * Removes a Sprite from the sketch.\n   * The removed Sprite won't be drawn or updated anymore.\n   * Equivalent to Sprite.remove()\n   *\n   * @method removeSprite\n   * @param {Object} sprite Sprite to be removed\n*/\np5.prototype.removeSprite = function(sprite) {\n  sprite.remove();\n};\n\n/**\n* Updates all the sprites in the sketch (position, animation...)\n* it's called automatically at every draw().\n* It can be paused by passing a parameter true or false;\n* Note: it does not render the sprites.\n*\n* @method updateSprites\n* @param {Boolean} updating false to pause the update, true to resume\n*/\np5.prototype.updateSprites = function(upd) {\n\n  if(upd === false)\n    this.spriteUpdate = false;\n  if(upd === true)\n    this.spriteUpdate = true;\n\n  if(this.spriteUpdate)\n  for(var i = 0; i<this.allSprites.size(); i++)\n  {\n    this.allSprites.get(i).update();\n  }\n};\n\n/**\n* Returns all the sprites in the sketch as an array\n*\n* @method getSprites\n* @return {Array} Array of Sprites\n*/\np5.prototype.getSprites = function() {\n\n  //draw everything\n  if(arguments.length===0)\n  {\n    return this.allSprites.toArray();\n  }\n  else\n  {\n    var arr = [];\n    //for every tag\n    for(var j=0; j<arguments.length; j++)\n    {\n      for(var i = 0; i<this.allSprites.size(); i++)\n      {\n        if(this.allSprites.get(i).isTagged(arguments[j]))\n          arr.push(this.allSprites.get(i));\n      }\n    }\n\n    return arr;\n  }\n\n};\n\n/**\n* Displays a Group of sprites.\n* If no parameter is specified, draws all sprites in the\n* sketch.\n* The drawing order is determined by the Sprite property \"depth\"\n*\n* @method drawSprites\n* @param {Group} [group] Group of Sprites to be displayed\n*/\np5.prototype.drawSprites = function(group) {\n  // If no group is provided, draw the allSprites group.\n  group = group || this.allSprites;\n\n  if (typeof group.draw !== 'function')\n  {\n    throw('Error: with drawSprites you can only draw all sprites or a group');\n  }\n\n  group.draw();\n};\n\n/**\n* Displays a Sprite.\n* To be typically used in the main draw function.\n*\n* @method drawSprite\n* @param {Sprite} sprite Sprite to be displayed\n*/\np5.prototype.drawSprite = function(sprite) {\n  if(sprite)\n  sprite.display();\n};\n\n/**\n* Loads an animation.\n* To be typically used in the preload() function of the sketch.\n*\n* @method loadAnimation\n* @param {Sprite} sprite Sprite to be displayed\n*/\np5.prototype.loadAnimation = function() {\n  return construct(this.Animation, arguments);\n};\n\n/**\n * Loads a Sprite Sheet.\n * To be typically used in the preload() function of the sketch.\n *\n * @method loadSpriteSheet\n */\np5.prototype.loadSpriteSheet = function() {\n  return construct(this.SpriteSheet, arguments);\n};\n\n/**\n* Displays an animation.\n*\n* @method animation\n* @param {Animation} anim Animation to be displayed\n* @param {Number} x X coordinate\n* @param {Number} y Y coordinate\n*\n*/\np5.prototype.animation = function(anim, x, y) {\n  anim.draw(x, y);\n};\n\n//variable to detect instant presses\ndefineLazyP5Property('_p5play', function() {\n  return {\n    keyStates: {},\n    mouseStates: {}\n  };\n});\n\nvar KEY_IS_UP = 0;\nvar KEY_WENT_DOWN = 1;\nvar KEY_IS_DOWN = 2;\nvar KEY_WENT_UP = 3;\n\n/**\n* Detects if a key was pressed during the last cycle.\n* It can be used to trigger events once, when a key is pressed or released.\n* Example: Super Mario jumping.\n*\n* @method keyWentDown\n* @param {Number|String} key Key code or character\n* @return {Boolean} True if the key was pressed\n*/\np5.prototype.keyWentDown = function(key) {\n  return this._isKeyInState(key, KEY_WENT_DOWN);\n};\n\n\n/**\n* Detects if a key was released during the last cycle.\n* It can be used to trigger events once, when a key is pressed or released.\n* Example: Spaceship shooting.\n*\n* @method keyWentUp\n* @param {Number|String} key Key code or character\n* @return {Boolean} True if the key was released\n*/\np5.prototype.keyWentUp = function(key) {\n  return this._isKeyInState(key, KEY_WENT_UP);\n};\n\n/**\n* Detects if a key is currently pressed\n* Like p5 keyIsDown but accepts strings and codes\n*\n* @method keyDown\n* @param {Number|String} key Key code or character\n* @return {Boolean} True if the key is down\n*/\np5.prototype.keyDown = function(key) {\n  return this._isKeyInState(key, KEY_IS_DOWN);\n};\n\n/**\n * Detects if a key is in the given state during the last cycle.\n * Helper method encapsulating common key state logic; it may be preferable\n * to call keyDown or other methods directly.\n *\n * @private\n * @method _isKeyInState\n * @param {Number|String} key Key code or character\n * @param {Number} state Key state to check against\n * @return {Boolean} True if the key is in the given state\n */\np5.prototype._isKeyInState = function(key, state) {\n  var keyCode;\n  var keyStates = this._p5play.keyStates;\n\n  if(typeof key === 'string')\n  {\n    keyCode = this._keyCodeFromAlias(key);\n  }\n  else\n  {\n    keyCode = key;\n  }\n\n  //if undefined start checking it\n  if(keyStates[keyCode]===undefined)\n  {\n    if(this.keyIsDown(keyCode))\n      keyStates[keyCode] = KEY_IS_DOWN;\n    else\n      keyStates[keyCode] = KEY_IS_UP;\n  }\n\n  return (keyStates[keyCode] === state);\n};\n\n/**\n* Detects if a mouse button is currently down\n* Combines mouseIsPressed and mouseButton of p5\n*\n* @method mouseDown\n* @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n* @return {Boolean} True if the button is down\n*/\np5.prototype.mouseDown = function(buttonCode) {\n  return this._isMouseButtonInState(buttonCode, KEY_IS_DOWN);\n};\n\n/**\n* Detects if a mouse button is currently up\n* Combines mouseIsPressed and mouseButton of p5\n*\n* @method mouseUp\n* @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n* @return {Boolean} True if the button is up\n*/\np5.prototype.mouseUp = function(buttonCode) {\n  return this._isMouseButtonInState(buttonCode, KEY_IS_UP);\n};\n\n/**\n * Detects if a mouse button was released during the last cycle.\n * It can be used to trigger events once, to be checked in the draw cycle\n *\n * @method mouseWentUp\n * @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n * @return {Boolean} True if the button was just released\n */\np5.prototype.mouseWentUp = function(buttonCode) {\n  return this._isMouseButtonInState(buttonCode, KEY_WENT_UP);\n};\n\n\n/**\n * Detects if a mouse button was pressed during the last cycle.\n * It can be used to trigger events once, to be checked in the draw cycle\n *\n * @method mouseWentDown\n * @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n * @return {Boolean} True if the button was just pressed\n */\np5.prototype.mouseWentDown = function(buttonCode) {\n  return this._isMouseButtonInState(buttonCode, KEY_WENT_DOWN);\n};\n\n/**\n * Detects if a mouse button is in the given state during the last cycle.\n * Helper method encapsulating common mouse button state logic; it may be\n * preferable to call mouseWentUp, etc, directly.\n *\n * @private\n * @method _isMouseButtonInState\n * @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n * @param {Number} state\n * @return {boolean} True if the button was in the given state\n */\np5.prototype._isMouseButtonInState = function(buttonCode, state) {\n  var mouseStates = this._p5play.mouseStates;\n\n  if(buttonCode === undefined)\n    buttonCode = this.LEFT;\n\n  //undefined = not tracked yet, start tracking\n  if(mouseStates[buttonCode]===undefined)\n  {\n  if(this.mouseIsPressed && this.mouseButton === buttonCode)\n    mouseStates[buttonCode] = KEY_IS_DOWN;\n  else\n    mouseStates[buttonCode] = KEY_IS_UP;\n  }\n\n  return (mouseStates[buttonCode] === state);\n};\n\n\n/**\n * An object storing all useful keys for easy access\n * Key.tab = 9\n *\n * @private\n * @property KEY\n * @type {Object}\n */\np5.prototype.KEY = {\n    'BACKSPACE': 8,\n    'TAB': 9,\n    'ENTER': 13,\n    'SHIFT': 16,\n    'CTRL': 17,\n    'ALT': 18,\n    'PAUSE': 19,\n    'CAPS_LOCK': 20,\n    'ESC': 27,\n    'SPACE': 32,\n    ' ': 32,\n    'PAGE_UP': 33,\n    'PAGE_DOWN': 34,\n    'END': 35,\n    'HOME': 36,\n    'LEFT_ARROW': 37,\n    'LEFT': 37,\n    'UP_ARROW': 38,\n    'UP': 38,\n    'RIGHT_ARROW': 39,\n    'RIGHT': 39,\n    'DOWN_ARROW': 40,\n    'DOWN': 40,\n    'INSERT': 45,\n    'DELETE': 46,\n    '0': 48,\n    '1': 49,\n    '2': 50,\n    '3': 51,\n    '4': 52,\n    '5': 53,\n    '6': 54,\n    '7': 55,\n    '8': 56,\n    '9': 57,\n    'A': 65,\n    'B': 66,\n    'C': 67,\n    'D': 68,\n    'E': 69,\n    'F': 70,\n    'G': 71,\n    'H': 72,\n    'I': 73,\n    'J': 74,\n    'K': 75,\n    'L': 76,\n    'M': 77,\n    'N': 78,\n    'O': 79,\n    'P': 80,\n    'Q': 81,\n    'R': 82,\n    'S': 83,\n    'T': 84,\n    'U': 85,\n    'V': 86,\n    'W': 87,\n    'X': 88,\n    'Y': 89,\n    'Z': 90,\n    '0NUMPAD': 96,\n    '1NUMPAD': 97,\n    '2NUMPAD': 98,\n    '3NUMPAD': 99,\n    '4NUMPAD': 100,\n    '5NUMPAD': 101,\n    '6NUMPAD': 102,\n    '7NUMPAD': 103,\n    '8NUMPAD': 104,\n    '9NUMPAD': 105,\n    'MULTIPLY': 106,\n    'PLUS': 107,\n    'MINUS': 109,\n    'DOT': 110,\n    'SLASH1': 111,\n    'F1': 112,\n    'F2': 113,\n    'F3': 114,\n    'F4': 115,\n    'F5': 116,\n    'F6': 117,\n    'F7': 118,\n    'F8': 119,\n    'F9': 120,\n    'F10': 121,\n    'F11': 122,\n    'F12': 123,\n    'EQUAL': 187,\n    'COMMA': 188,\n    'SLASH': 191,\n    'BACKSLASH': 220\n};\n\n/**\n * An object storing deprecated key aliases, which we still support but\n * should be mapped to valid aliases and generate warnings.\n *\n * @private\n * @property KEY_DEPRECATIONS\n * @type {Object}\n */\np5.prototype.KEY_DEPRECATIONS = {\n  'MINUT': 'MINUS',\n  'COMA': 'COMMA'\n};\n\n/**\n * Given a string key alias (as defined in the KEY property above), look up\n * and return the numeric JavaScript key code for that key.  If a deprecated\n * alias is passed (as defined in the KEY_DEPRECATIONS property) it will be\n * mapped to a valid key code, but will also generate a warning about use\n * of the deprecated alias.\n *\n * @private\n * @method _keyCodeFromAlias\n * @param {!string} alias - a case-insensitive key alias\n * @return {number|undefined} a numeric JavaScript key code, or undefined\n *          if no key code matching the given alias is found.\n */\np5.prototype._keyCodeFromAlias = function(alias) {\n  alias = alias.toUpperCase();\n  if (this.KEY_DEPRECATIONS[alias]) {\n    this._warn('Key literal \"' + alias + '\" is deprecated and may be removed ' +\n      'in a future version of p5.play. ' +\n      'Please use \"' + this.KEY_DEPRECATIONS[alias] + '\" instead.');\n    alias = this.KEY_DEPRECATIONS[alias];\n  }\n  return this.KEY[alias];\n};\n\n//pre draw: detect keyStates\np5.prototype.readPresses = function() {\n  var keyStates = this._p5play.keyStates;\n  var mouseStates = this._p5play.mouseStates;\n\n  for (var key in keyStates) {\n    if(this.keyIsDown(key)) //if is down\n    {\n      if(keyStates[key] === KEY_IS_UP)//and was up\n        keyStates[key] = KEY_WENT_DOWN;\n      else\n        keyStates[key] = KEY_IS_DOWN; //now is simply down\n    }\n    else //if it's up\n    {\n      if(keyStates[key] === KEY_IS_DOWN)//and was up\n        keyStates[key] = KEY_WENT_UP;\n      else\n        keyStates[key] = KEY_IS_UP; //now is simply down\n    }\n  }\n\n  //mouse\n  for (var btn in mouseStates) {\n\n    if(this.mouseIsPressed && this.mouseButton === btn) //if is down\n    {\n      if(mouseStates[btn] === KEY_IS_UP)//and was up\n        mouseStates[btn] = KEY_WENT_DOWN;\n      else\n        mouseStates[btn] = KEY_IS_DOWN; //now is simply down\n    }\n    else //if it's up\n    {\n      if(mouseStates[btn] === KEY_IS_DOWN)//and was up\n        mouseStates[btn] = KEY_WENT_UP;\n      else\n        mouseStates[btn] = KEY_IS_UP; //now is simply down\n    }\n  }\n\n};\n\n/**\n* Turns the quadTree on or off.\n* A quadtree is a data structure used to optimize collision detection.\n* It can improve performance when there is a large number of Sprites to be\n* checked continuously for overlapping.\n*\n* p5.play will create and update a quadtree automatically.\n*\n* @method useQuadTree\n* @param {Boolean} use Pass true to enable, false to disable\n*/\np5.prototype.useQuadTree = function(use) {\n\n  if(this.quadTree !== undefined)\n  {\n    if(use === undefined)\n      return this.quadTree.active;\n    else if(use)\n      this.quadTree.active = true;\n    else\n      this.quadTree.active = false;\n  }\n  else\n    return false;\n};\n\n//the actual quadTree\ndefineLazyP5Property('quadTree', function() {\n  return new Quadtree({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }, 4);\n});\n\n/*\n//framerate independent delta, doesn't really work\np5.prototype.deltaTime = 1;\n\nvar now = Date.now();\nvar then = Date.now();\nvar INTERVAL_60 = 0.0166666; //60 fps\n\nfunction updateDelta() {\nthen = now;\nnow = Date.now();\ndeltaTime = ((now - then) / 1000)/INTERVAL_60; // seconds since last frame\n}\n*/\n\n/**\n   * A Sprite is the main building block of p5.play:\n   * an element able to store images or animations with a set of\n   * properties such as position and visibility.\n   * A Sprite can have a collider that defines the active area to detect\n   * collisions or overlappings with other sprites and mouse interactions.\n   *\n   * To create a Sprite, use\n   * {{#crossLink \"p5.play/createSprite:method\"}}{{/crossLink}}.\n   *\n   * @class Sprite\n   */\n\n// For details on why these docs aren't in a YUIDoc comment block, see:\n//\n// https://github.com/molleindustria/p5.play/pull/67\n//\n// @param {Number} x Initial x coordinate\n// @param {Number} y Initial y coordinate\n// @param {Number} width Width of the placeholder rectangle and of the\n//                       collider until an image or new collider are set\n// @param {Number} height Height of the placeholder rectangle and of the\n//                        collider until an image or new collider are set\nfunction Sprite(pInst, _x, _y, _w, _h) {\n  var pInstBind = createPInstBinder(pInst);\n\n  var createVector = pInstBind('createVector');\n  var color = pInstBind('color');\n  var random = pInstBind('random');\n  var print = pInstBind('print');\n  var push = pInstBind('push');\n  var pop = pInstBind('pop');\n  var colorMode = pInstBind('colorMode');\n  var noStroke = pInstBind('noStroke');\n  var rectMode = pInstBind('rectMode');\n  var ellipseMode = pInstBind('ellipseMode');\n  var imageMode = pInstBind('imageMode');\n  var translate = pInstBind('translate');\n  var scale = pInstBind('scale');\n  var rotate = pInstBind('rotate');\n  var stroke = pInstBind('stroke');\n  var strokeWeight = pInstBind('strokeWeight');\n  var line = pInstBind('line');\n  var noFill = pInstBind('noFill');\n  var fill = pInstBind('fill');\n  var textAlign = pInstBind('textAlign');\n  var textSize = pInstBind('textSize');\n  var text = pInstBind('text');\n  var rect = pInstBind('rect');\n  var cos = pInstBind('cos');\n  var sin = pInstBind('sin');\n  var atan2 = pInstBind('atan2');\n\n  var quadTree = pInst.quadTree;\n  var camera = pInst.camera;\n\n\n  // These are p5 constants that we'd like easy access to.\n  var RGB = p5.prototype.RGB;\n  var CENTER = p5.prototype.CENTER;\n  var LEFT = p5.prototype.LEFT;\n  var BOTTOM = p5.prototype.BOTTOM;\n\n  /**\n  * The sprite's position of the sprite as a vector (x,y).\n  * @property position\n  * @type {p5.Vector}\n  */\n  this.position = createVector(_x, _y);\n\n  /**\n  * The sprite's position at the beginning of the last update as a vector (x,y).\n  * @property previousPosition\n  * @type {p5.Vector}\n  */\n  this.previousPosition = createVector(_x, _y);\n\n  /*\n  The sprite's position at the end of the last update as a vector (x,y).\n  Note: this will differ from position whenever the position is changed\n  directly by assignment.\n  */\n  this.newPosition = createVector(_x, _y);\n\n  //Position displacement on the x coordinate since the last update\n  this.deltaX = 0;\n  this.deltaY = 0;\n\n  /**\n  * The sprite's velocity as a vector (x,y)\n  * Velocity is speed broken down to its vertical and horizontal components.\n  *\n  * @property velocity\n  * @type {p5.Vector}\n  */\n  this.velocity = createVector(0, 0);\n\n  /**\n  * Set a limit to the sprite's scalar speed regardless of the direction.\n  * The value can only be positive. If set to -1, there's no limit.\n  *\n  * @property maxSpeed\n  * @type {Number}\n  * @default -1\n  */\n  this.maxSpeed = -1;\n\n  /**\n  * Friction factor, reduces the sprite's velocity.\n  * The friction should be close to 0 (eg. 0.01)\n  * 0: no friction\n  * 1: full friction\n  *\n  * @property friction\n  * @type {Number}\n  * @default 0\n  */\n  this.friction = 0;\n\n  /**\n  * The sprite's current collider.\n  * It can either be an Axis Aligned Bounding Box (a non-rotated rectangle)\n  * or a circular collider.\n  * If the sprite is checked for collision, bounce, overlapping or mouse events the\n  * collider is automatically created from the width and height\n  * of the sprite or from the image dimension in case of animate sprites\n  *\n  * You can set a custom collider with Sprite.setCollider\n  *\n  * @property collider\n  * @type {Object}\n  */\n  this.collider = undefined;\n\n  //internal use\n  //\"default\" - no image or custom collider is specified, use the shape width / height\n  //\"custom\" - specified with setCollider\n  //\"image\" - no collider is set with setCollider and an image is added\n  this.colliderType = 'none';\n\n  /**\n  * Object containing information about the most recent collision/overlapping\n  * To be typically used in combination with Sprite.overlap or Sprite.collide\n  * functions.\n  * The properties are touching.left, touching.right, touching.top,\n  * touching.bottom and are either true or false depending on the side of the\n  * collider.\n  *\n  * @property touching\n  * @type {Object}\n  */\n  this.touching = {};\n  this.touching.left = false;\n  this.touching.right = false;\n  this.touching.top = false;\n  this.touching.bottom = false;\n\n  /**\n  * The mass determines the velocity transfer when sprites bounce\n  * against each other. See Sprite.bounce\n  * The higher the mass the least the sprite will be affected by collisions.\n  *\n  * @property mass\n  * @type {Number}\n  * @default 1\n  */\n  this.mass = 1;\n\n  /**\n  * If set to true the sprite won't bounce or be displaced by collisions\n  * Simulates an infinite mass or an anchored object.\n  *\n  * @property immovable\n  * @type {Boolean}\n  * @default false\n  */\n  this.immovable = false;\n\n  //Coefficient of restitution - velocity lost in the bouncing\n  //0 perfectly inelastic , 1 elastic, > 1 hyper elastic\n\n  /**\n  * Coefficient of restitution. The velocity lost after bouncing.\n  * 1: perfectly elastic, no energy is lost\n  * 0: perfectly inelastic, no bouncing\n  * less than 1: inelastic, this is the most common in nature\n  * greater than 1: hyper elastic, energy is increased like in a pinball bumper\n  *\n  * @property restitution\n  * @type {Number}\n  * @default 1\n  */\n  this.restitution = 1;\n\n  /**\n  * Rotation in degrees of the visual element (image or animation)\n  * Note: this is not the movement's direction, see getDirection.\n  *\n  * @property rotation\n  * @type {Number}\n  * @default 0\n  */\n  Object.defineProperty(this, 'rotation', {\n    enumerable: true,\n    get: function() {\n      return this._rotation;\n    },\n    set: function(value) {\n      this._rotation = value;\n      if (this.rotateToDirection) {\n        this.setSpeed(this.getSpeed(), value);\n      }\n    }\n  });\n\n  /**\n  * Internal rotation variable (expressed in degrees).\n  * Note: external callers access this through the rotation property above.\n  *\n  * @private\n  * @property _rotation\n  * @type {Number}\n  * @default 0\n  */\n  this._rotation = 0;\n\n  /**\n  * Rotation change in degrees per frame of thevisual element (image or animation)\n  * Note: this is not the movement's direction, see getDirection.\n  *\n  * @property rotationSpeed\n  * @type {Number}\n  * @default 0\n  */\n  this.rotationSpeed = 0;\n\n\n  /**\n  * Automatically lock the rotation property of the visual element\n  * (image or animation) to the sprite's movement direction and vice versa.\n  *\n  * @property rotateToDirection\n  * @type {Boolean}\n  * @default false\n  */\n  this.rotateToDirection = false;\n\n\n  /**\n  * Determines the rendering order within a group: a sprite with\n  * lower depth will appear below the ones with higher depth.\n  *\n  * Note: drawing a group before another with drawSprites will make\n  * its members appear below the second one, like in normal p5 canvas\n  * drawing.\n  *\n  * @property depth\n  * @type {Number}\n  * @default One more than the greatest existing sprite depth, when calling\n  *          createSprite().  When calling new Sprite() directly, depth will\n  *          initialize to 0 (not recommended).\n  */\n  this.depth = 0;\n\n  /**\n  * Determines the sprite's scale.\n  * Example: 2 will be twice the native size of the visuals,\n  * 0.5 will be half. Scaling up may make images blurry.\n  *\n  * @property scale\n  * @type {Number}\n  * @default 1\n  */\n  this.scale = 1;\n\n  var dirX = 1;\n  var dirY = 1;\n\n  /**\n  * The sprite's visibility.\n  *\n  * @property visible\n  * @type {Boolean}\n  * @default true\n  */\n  this.visible = true;\n\n  /**\n  * If set to true sprite will track its mouse state.\n  * the properties mouseIsPressed and mouseIsOver will be updated.\n  * Note: automatically set to true if the functions\n  * onMouseReleased or onMousePressed are set.\n  *\n  * @property mouseActive\n  * @type {Boolean}\n  * @default false\n  */\n  this.mouseActive = false;\n\n  /**\n  * True if mouse is on the sprite's collider.\n  * Read only.\n  *\n  * @property mouseIsOver\n  * @type {Boolean}\n  */\n  this.mouseIsOver = false;\n\n  /**\n  * True if mouse is pressed on the sprite's collider.\n  * Read only.\n  *\n  * @property mouseIsPressed\n  * @type {Boolean}\n  */\n  this.mouseIsPressed = false;\n\n  /*\n  * Width of the sprite's current image.\n  * If no images or animations are set it's the width of the\n  * placeholder rectangle.\n  * Used internally to make calculations and draw the sprite.\n  *\n  * @private\n  * @property _internalWidth\n  * @type {Number}\n  * @default 100\n  */\n  this._internalWidth = _w;\n\n  /*\n  * Height of the sprite's current image.\n  * If no images or animations are set it's the height of the\n  * placeholder rectangle.\n  * Used internally to make calculations and draw the sprite.\n  *\n  * @private\n  * @property _internalHeight\n  * @type {Number}\n  * @default 100\n  */\n  this._internalHeight = _h;\n\n  /*\n   * _internalWidth and _internalHeight are used for all p5.play\n   * calculations, but width and height can be extended. For example,\n   * you may want users to always get and set a scaled width:\n      Object.defineProperty(this, 'width', {\n        enumerable: true,\n        configurable: true,\n        get: function() {\n          return this._internalWidth * this.scale;\n        },\n        set: function(value) {\n          this._internalWidth = value / this.scale;\n        }\n      });\n   */\n\n  /**\n  * Width of the sprite's current image.\n  * If no images or animations are set it's the width of the\n  * placeholder rectangle.\n  *\n  * @property width\n  * @type {Number}\n  * @default 100\n  */\n  Object.defineProperty(this, 'width', {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      return this._internalWidth;\n    },\n    set: function(value) {\n      this._internalWidth = value;\n    }\n  });\n\n  if(_w === undefined)\n    this.width = 100;\n  else\n    this.width = _w;\n\n  /**\n  * Height of the sprite's current image.\n  * If no images or animations are set it's the height of the\n  * placeholder rectangle.\n  *\n  * @property height\n  * @type {Number}\n  * @default 100\n  */\n  Object.defineProperty(this, 'height', {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      return this._internalHeight;\n    },\n    set: function(value) {\n      this._internalHeight = value;\n    }\n  });\n\n  if(_h === undefined)\n    this.height = 100;\n  else\n    this.height = _h;\n\n  /**\n  * Unscaled width of the sprite\n  * If no images or animations are set it's the width of the\n  * placeholder rectangle.\n  *\n  * @property originalWidth\n  * @type {Number}\n  * @default 100\n  */\n  this.originalWidth = this._internalWidth;\n\n  /**\n  * Unscaled height of the sprite\n  * If no images or animations are set it's the height of the\n  * placeholder rectangle.\n  *\n  * @property originalHeight\n  * @type {Number}\n  * @default 100\n  */\n  this.originalHeight = this._internalHeight;\n\n  /**\n  * True if the sprite has been removed.\n  *\n  * @property removed\n  * @type {Boolean}\n  */\n  this.removed = false;\n\n  /**\n  * Cycles before self removal.\n  * Set it to initiate a countdown, every draw cycle the property is\n  * reduced by 1 unit. At 0 it will call a sprite.remove()\n  * Disabled if set to -1.\n  *\n  * @property life\n  * @type {Number}\n  * @default -1\n  */\n  this.life = -1;\n\n  /**\n  * If set to true, draws an outline of the collider, the depth, and center.\n  *\n  * @property debug\n  * @type {Boolean}\n  * @default false\n  */\n  this.debug = false;\n\n  /**\n  * If no image or animations are set this is color of the\n  * placeholder rectangle\n  *\n  * @property shapeColor\n  * @type {color}\n  */\n  this.shapeColor = color(random(255), random(255), random(255));\n\n  /**\n  * Groups the sprite belongs to, including allSprites\n  *\n  * @property groups\n  * @type {Array}\n  */\n  this.groups = [];\n\n  var animations = {};\n\n  //The current animation's label.\n  var currentAnimation = '';\n\n  /**\n  * Reference to the current animation.\n  *\n  * @property animation\n  * @type {Animation}\n  */\n  this.animation = undefined;\n\n  /*\n   * @private\n   * Keep animation properties in sync with how the animation changes.\n   */\n  this._syncAnimationSizes = function() {\n    //has an animation but the collider is still default\n    //the animation wasn't loaded. if the animation is not a 1x1 image\n    //it means it just finished loading\n    if(this.colliderType === 'default' &&\n      animations[currentAnimation].getWidth() !== 1 && animations[currentAnimation].getHeight() !== 1)\n    {\n      this.collider = this.getBoundingBox();\n      this.colliderType = 'image';\n      this._internalWidth = animations[currentAnimation].getWidth()*abs(this._getScaleX());\n      this._internalHeight = animations[currentAnimation].getHeight()*abs(this._getScaleY());\n      //quadTree.insert(this);\n    }\n\n    //update size and collider\n    if(animations[currentAnimation].frameChanged || this.width === undefined || this.height === undefined)\n    {\n      //this.collider = this.getBoundingBox();\n      this._internalWidth = animations[currentAnimation].getWidth()*abs(this._getScaleX());\n      this._internalHeight = animations[currentAnimation].getHeight()*abs(this._getScaleY());\n    }\n  };\n\n  /**\n  * Updates the sprite.\n  * Called automatically at the beginning of the draw cycle.\n  *\n  * @method update\n  */\n  this.update = function() {\n\n    if(!this.removed)\n    {\n      //if there has been a change somewhere after the last update\n      //the old position is the last position registered in the update\n      if(this.newPosition !== this.position)\n        this.previousPosition = createVector(this.newPosition.x, this.newPosition.y);\n      else\n        this.previousPosition = createVector(this.position.x, this.position.y);\n\n      this.velocity.x *= 1 - this.friction;\n      this.velocity.y *= 1 - this.friction;\n\n      if(this.maxSpeed !== -1)\n        this.limitSpeed(this.maxSpeed);\n\n      if(this.rotateToDirection && this.velocity.mag() > 0)\n        this._rotation = this.getDirection();\n\n      this.rotation += this.rotationSpeed;\n\n      this.position.x += this.velocity.x;\n      this.position.y += this.velocity.y;\n\n      this.newPosition = createVector(this.position.x, this.position.y);\n\n      this.deltaX = this.position.x - this.previousPosition.x;\n      this.deltaY = this.position.y - this.previousPosition.y;\n\n      //if there is an animation\n      if(animations[currentAnimation])\n      {\n        //update it\n        animations[currentAnimation].update();\n\n        this._syncAnimationSizes();\n      }\n\n      //a collider is created either manually with setCollider or\n      //when I check this sprite for collisions or overlaps\n      if(this.collider)\n      {\n        if(this.collider instanceof AABB)\n        {\n        //scale / rotate collider\n        var t;\n        if (pInst._angleMode === pInst.RADIANS) {\n          t = radians(this.rotation);\n        } else {\n          t = this.rotation;\n        }\n\n        if(this.colliderType === 'custom')\n          {\n          this.collider.extents.x = this.collider.originalExtents.x * abs(this._getScaleX()) * abs(cos(t)) +\n          this.collider.originalExtents.y * abs(this._getScaleY()) * abs(sin(t));\n\n          this.collider.extents.y = this.collider.originalExtents.x * abs(this._getScaleX()) * abs(sin(t)) +\n          this.collider.originalExtents.y * abs(this._getScaleY()) * abs(cos(t));\n          }\n        else if(this.colliderType === 'default')\n          {\n          this.collider.extents.x = this._internalWidth * abs(this._getScaleX()) * abs(cos(t)) +\n          this._internalHeight * abs(this._getScaleY()) * abs(sin(t));\n          this.collider.extents.y = this._internalWidth * abs(this._getScaleX()) * abs(sin(t)) +\n          this._internalHeight * abs(this._getScaleY()) * abs(cos(t));\n          }\n        else if(this.colliderType === 'image')\n          {\n          this.collider.extents.x = this._internalWidth * abs(cos(t)) +\n          this._internalHeight * abs(sin(t));\n\n          this.collider.extents.y = this._internalWidth * abs(sin(t)) +\n          this._internalHeight * abs(cos(t));\n          }\n        }\n\n        if(this.collider instanceof CircleCollider)\n        {\n        //print(this.scale);\n        this.collider.radius = this.collider.originalRadius * abs(this.scale);\n        }\n\n      }//end collider != null\n\n      //mouse actions\n      if (this.mouseActive)\n      {\n        //if no collider set it\n          if(!this.collider)\n            this.setDefaultCollider();\n\n        this.mouseUpdate();\n      }\n      else\n      {\n        if (typeof(this.onMouseOver) === 'function' ||\n            typeof(this.onMouseOut) === 'function' ||\n            typeof(this.onMousePressed) === 'function' ||\n            typeof(this.onMouseReleased) === 'function')\n        {\n          //if a mouse function is set\n          //it's implied we want to have it mouse active so\n          //we do this automatically\n          this.mouseActive = true;\n\n          //if no collider set it\n          if(!this.collider)\n            this.setDefaultCollider();\n\n          this.mouseUpdate();\n        }\n      }\n\n      //self destruction countdown\n      if (this.life>0)\n        this.life--;\n      if (this.life === 0)\n        this.remove();\n    }\n  };//end update\n\n  /**\n   * Creates a default collider matching the size of the\n   * placeholder rectangle or the bounding box of the image.\n   *\n   * @method setDefaultCollider\n   */\n  this.setDefaultCollider = function() {\n\n    //if has animation get the animation bounding box\n    //working only for preloaded images\n    if(animations[currentAnimation] && (animations[currentAnimation].getWidth() !== 1 && animations[currentAnimation].getHeight() !== 1))\n    {\n      this.collider = this.getBoundingBox();\n      this._internalWidth = animations[currentAnimation].getWidth()*abs(this._getScaleX());\n      this._internalHeight = animations[currentAnimation].getHeight()*abs(this._getScaleY());\n      //quadTree.insert(this);\n      this.colliderType = 'image';\n      //print(\"IMAGE COLLIDER ADDED\");\n    }\n    else if(animations[currentAnimation] && animations[currentAnimation].getWidth() === 1 && animations[currentAnimation].getHeight() === 1)\n    {\n    //animation is still loading\n    //print(\"wait\");\n    }\n    else //get the with and height defined at the creation\n    {\n      this.collider = new AABB(pInst, this.position, createVector(this._internalWidth, this._internalHeight));\n      //quadTree.insert(this);\n      this.colliderType = 'default';\n    }\n\n    pInst.quadTree.insert(this);\n  };\n\n  /**\n   * Updates the sprite mouse states and triggers the mouse events:\n   * onMouseOver, onMouseOut, onMousePressed, onMouseReleased\n   *\n   * @method mouseUpdate\n   */\n  this.mouseUpdate = function() {\n\n    var mouseWasOver = this.mouseIsOver;\n    var mouseWasPressed = this.mouseIsPressed;\n\n    this.mouseIsOver = false;\n    this.mouseIsPressed = false;\n\n    var mousePosition;\n\n    if(camera.active)\n      mousePosition = createVector(camera.mouseX, camera.mouseY);\n    else\n      mousePosition = createVector(pInst.mouseX, pInst.mouseY);\n\n      //rollover\n      if(this.collider)\n      {\n\n        if (this.collider instanceof CircleCollider)\n        {\n          if (dist(mousePosition.x, mousePosition.y, this.collider.center.x, this.collider.center.y) < this.collider.radius)\n            this.mouseIsOver = true;\n        } else if (this.collider instanceof AABB)\n        {\n          if (mousePosition.x > this.collider.left() &&\n              mousePosition.y > this.collider.top() &&\n              mousePosition.x < this.collider.right() &&\n              mousePosition.y < this.collider.bottom())\n          {\n            this.mouseIsOver = true;\n          }\n        }\n\n        //global p5 var\n        if(this.mouseIsOver && pInst.mouseIsPressed)\n          this.mouseIsPressed = true;\n\n        //event change - call functions\n        if(!mouseWasOver && this.mouseIsOver && this.onMouseOver !== undefined)\n          if(typeof(this.onMouseOver) === 'function')\n            this.onMouseOver.call(this, this);\n          else\n            print('Warning: onMouseOver should be a function');\n\n        if(mouseWasOver && !this.mouseIsOver && this.onMouseOut !== undefined)\n          if(typeof(this.onMouseOut) === 'function')\n            this.onMouseOut.call(this, this);\n          else\n            print('Warning: onMouseOut should be a function');\n\n        if(!mouseWasPressed && this.mouseIsPressed && this.onMousePressed !== undefined)\n          if(typeof(this.onMousePressed) === 'function')\n            this.onMousePressed.call(this, this);\n          else\n            print('Warning: onMousePressed should be a function');\n\n        if(mouseWasPressed && !pInst.mouseIsPressed && !this.mouseIsPressed && this.onMouseReleased !== undefined)\n          if(typeof(this.onMouseReleased) === 'function')\n            this.onMouseReleased.call(this, this);\n          else\n            print('Warning: onMouseReleased should be a function');\n\n      }\n\n  };\n\n  /**\n  * Sets a collider for the sprite.\n  *\n  * In p5.play a Collider is an invisible circle or rectangle\n  * that can have any size or position relative to the sprite and which\n  * will be used to detect collisions and overlapping with other sprites,\n  * or the mouse cursor.\n  *\n  * If the sprite is checked for collision, bounce, overlapping or mouse events\n  * a collider is automatically created from the width and height parameter\n  * passed at the creation of the sprite or the from the image dimension in case\n  * of animated sprites.\n  *\n  * Often the image bounding box is not appropriate as the active area for\n  * collision detection so you can set a circular or rectangular sprite with\n  * different dimensions and offset from the sprite's center.\n  *\n  * There are four ways to call this method:\n  *\n  * 1. setCollider(\"rectangle\")\n  * 2. setCollider(\"rectangle\", offsetX, offsetY, width, height)\n  * 3. setCollider(\"circle\")\n  * 4. setCollider(\"circle\", offsetX, offsetY, radius)\n  *\n  * @method setCollider\n  * @param {String} type Either \"rectangle\" or \"circle\"\n  * @param {Number} offsetX Collider x position from the center of the sprite\n  * @param {Number} offsetY Collider y position from the center of the sprite\n  * @param {Number} width Collider width or radius\n  * @param {Number} height Collider height\n  * @throws {TypeError} if given invalid parameters.\n  */\n  this.setCollider = function(type, offsetX, offsetY, width, height) {\n    if (!(type === 'rectangle' || type === 'circle')) {\n      throw new TypeError('setCollider expects the first argument to be either \"circle\" or \"rectangle\"');\n    } else if (type === 'circle' && arguments.length > 1 && arguments.length < 4) {\n      throw new TypeError('Usage: setCollider(\"circle\") or setCollider(\"circle\", offsetX, offsetY, radius)');\n    } else if (type === 'circle' && arguments.length > 4) {\n      pInst._warn('Extra parameters to setCollider were ignored. Usage: setCollider(\"circle\") or setCollider(\"circle\", offsetX, offsetY, radius)');\n    } else if (type === 'rectangle' && arguments.length > 1 && arguments.length < 5) {\n      throw new TypeError('Usage: setCollider(\"rectangle\") or setCollider(\"rectangle\", offsetX, offsetY, width, height)');\n    } else if (type === 'rectangle' && arguments.length > 5) {\n      pInst._warn('Extra parameters to setCollider were ignored. Usage: setCollider(\"rectangle\") or setCollider(\"rectangle\", offsetX, offsetY, width, height)');\n    }\n\n    this.colliderType = 'custom';\n\n    var v = createVector(offsetX, offsetY);\n    if (type === 'rectangle' && arguments.length === 1) {\n      this.collider = new AABB(pInst, this.position, createVector(this.width, this.height));\n    } else if (type === 'rectangle' && arguments.length >= 5) {\n      this.collider = new AABB(pInst, this.position, createVector(width, height), v);\n    } else if (type === 'circle' && arguments.length === 1) {\n      this.collider = new CircleCollider(pInst, this.position, Math.floor(Math.max(this.width, this.height) / 2));\n    } else if (type === 'circle' && arguments.length >= 4) {\n      this.collider = new CircleCollider(pInst, this.position, width, v);\n    }\n\n    quadTree.insert(this);\n  };\n\n  /**\n   * Returns a the bounding box of the current image\n   * @method getBoundingBox\n   */\n  this.getBoundingBox = function() {\n\n    var w = animations[currentAnimation].getWidth()*abs(this._getScaleX());\n    var h = animations[currentAnimation].getHeight()*abs(this._getScaleY());\n\n    //if the bounding box is 1x1 the image is not loaded\n    //potential issue with actual 1x1 images\n    if(w === 1 && h === 1) {\n      //not loaded yet\n      return new AABB(pInst, this.position, createVector(w, h));\n    }\n    else {\n      return new AABB(pInst, this.position, createVector(w, h));\n    }\n  };\n\n  /**\n  * Sets the sprite's horizontal mirroring.\n  * If 1 the images displayed normally\n  * If -1 the images are flipped horizontally\n  * If no argument returns the current x mirroring\n  *\n  * @method mirrorX\n  * @param {Number} dir Either 1 or -1\n  * @return {Number} Current mirroring if no parameter is specified\n  */\n  this.mirrorX = function(dir) {\n    if(dir === 1 || dir === -1)\n      dirX = dir;\n    else\n      return dirX;\n  };\n\n  /**\n  * Sets the sprite's vertical mirroring.\n  * If 1 the images displayed normally\n  * If -1 the images are flipped vertically\n  * If no argument returns the current y mirroring\n  *\n  * @method mirrorY\n  * @param {Number} dir Either 1 or -1\n  * @return {Number} Current mirroring if no parameter is specified\n  */\n  this.mirrorY = function(dir) {\n    if(dir === 1 || dir === -1)\n      dirY = dir;\n    else\n      return dirY;\n  };\n\n  /*\n   * Returns the value the sprite should be scaled in the X direction.\n   * Used to calculate rendering and collisions.\n   * @private\n   */\n  this._getScaleX = function()\n  {\n    return this.scale;\n  };\n\n  /*\n   * Returns the value the sprite should be scaled in the Y direction.\n   * Used to calculate rendering and collisions.\n   * @private\n   */\n  this._getScaleY = function()\n  {\n    return this.scale;\n  };\n\n  /**\n   * Manages the positioning, scale and rotation of the sprite\n   * Called automatically, it should not be overridden\n   * @private\n   * @final\n   * @method display\n   */\n  this.display = function()\n  {\n    if (this.visible && !this.removed)\n    {\n      push();\n      colorMode(RGB);\n\n      noStroke();\n      rectMode(CENTER);\n      ellipseMode(CENTER);\n      imageMode(CENTER);\n\n      translate(this.position.x, this.position.y);\n      scale(this._getScaleX()*dirX, this._getScaleY()*dirY);\n      if (pInst._angleMode === pInst.RADIANS) {\n        rotate(radians(this.rotation));\n      } else {\n        rotate(this.rotation);\n      }\n      this.draw();\n      //draw debug info\n      pop();\n\n\n      if(this.debug)\n      {\n        push();\n        //draw the anchor point\n        stroke(0, 255, 0);\n        strokeWeight(1);\n        line(this.position.x-10, this.position.y, this.position.x+10, this.position.y);\n        line(this.position.x, this.position.y-10, this.position.x, this.position.y+10);\n        noFill();\n\n        //depth number\n        noStroke();\n        fill(0, 255, 0);\n        textAlign(LEFT, BOTTOM);\n        textSize(16);\n        text(this.depth+'', this.position.x+4, this.position.y-2);\n\n        noFill();\n        stroke(0, 255, 0);\n\n        //bounding box\n        if(this.collider !== undefined)\n        {\n          this.collider.draw();\n        }\n        pop();\n      }\n\n    }\n  };\n\n\n  /**\n  * Manages the visuals of the sprite.\n  * It can be overridden with a custom drawing function.\n  * The 0,0 point will be the center of the sprite.\n  * Example:\n  * sprite.draw = function() { ellipse(0,0,10,10) }\n  * Will display the sprite as circle.\n  *\n  * @method draw\n  */\n  this.draw = function()\n  {\n    if(currentAnimation !== '' && animations)\n    {\n      if(animations[currentAnimation])\n        animations[currentAnimation].draw(0, 0, 0);\n    }\n    else\n    {\n      noStroke();\n      fill(this.shapeColor);\n      rect(0, 0, this._internalWidth, this._internalHeight);\n    }\n  };\n\n  /**\n   * Removes the Sprite from the sketch.\n   * The removed Sprite won't be drawn or updated anymore.\n   *\n   * @method remove\n   */\n  this.remove = function() {\n    this.removed = true;\n\n    quadTree.removeObject(this);\n\n    //when removed from the \"scene\" also remove all the references in all the groups\n    while (this.groups.length > 0) {\n      this.groups[0].remove(this);\n    }\n  };\n\n  /**\n  * Sets the velocity vector.\n  *\n  * @method setVelocity\n  * @param {Number} x X component\n  * @param {Number} y Y component\n  */\n  this.setVelocity = function(x, y) {\n    this.velocity.x = x;\n    this.velocity.y = y;\n  };\n\n  /**\n  * Calculates the scalar speed.\n  *\n  * @method getSpeed\n  * @return {Number} Scalar speed\n  */\n  this.getSpeed = function() {\n    return this.velocity.mag();\n  };\n\n  /**\n  * Calculates the movement's direction in degrees.\n  *\n  * @method getDirection\n  * @return {Number} Angle in degrees\n  */\n  this.getDirection = function() {\n\n    var direction = atan2(this.velocity.y, this.velocity.x);\n\n    if(isNaN(direction))\n      direction = 0;\n\n    // Unlike Math.atan2, the atan2 method above will return degrees if\n    // the current p5 angleMode is DEGREES, and radians if the p5 angleMode is\n    // RADIANS.  This method should always return degrees (for now).\n    // See https://github.com/molleindustria/p5.play/issues/94\n    if (pInst._angleMode === pInst.RADIANS) {\n      direction = degrees(direction);\n    }\n\n    return direction;\n  };\n\n  /**\n  * Adds the sprite to an existing group\n  *\n  * @method addToGroup\n  * @param {Object} group\n  */\n  this.addToGroup = function(group) {\n    if(group instanceof Array)\n      group.add(this);\n    else\n      print('addToGroup error: '+group+' is not a group');\n  };\n\n  /**\n  * Limits the scalar speed.\n  *\n  * @method limitSpeed\n  * @param {Number} max Max speed: positive number\n  */\n  this.limitSpeed = function(max) {\n\n    //update linear speed\n    var speed = this.getSpeed();\n\n    if(abs(speed)>max)\n    {\n      //find reduction factor\n      var k = max/abs(speed);\n      this.velocity.x *= k;\n      this.velocity.y *= k;\n    }\n  };\n\n  /**\n  * Set the speed and direction of the sprite.\n  * The action overwrites the current velocity.\n  * If direction is not supplied, the current direction is maintained.\n  * If direction is not supplied and there is no current velocity, the current\n  * rotation angle used for the direction.\n  *\n  * @method setSpeed\n  * @param {Number}  speed Scalar speed\n  * @param {Number}  [angle] Direction in degrees\n  */\n  this.setSpeed = function(speed, angle) {\n    var a;\n    if (typeof angle === 'undefined') {\n      if (this.velocity.x !== 0 || this.velocity.y !== 0) {\n        a = pInst.atan2(this.velocity.y, this.velocity.x);\n      } else {\n        if (pInst._angleMode === pInst.RADIANS) {\n          a = radians(this._rotation);\n        } else {\n          a = this._rotation;\n        }\n      }\n    } else {\n      if (pInst._angleMode === pInst.RADIANS) {\n        a = radians(angle);\n      } else {\n        a = angle;\n      }\n    }\n    this.velocity.x = cos(a)*speed;\n    this.velocity.y = sin(a)*speed;\n  };\n\n  /**\n  * Pushes the sprite in a direction defined by an angle.\n  * The force is added to the current velocity.\n  *\n  * @method addSpeed\n  * @param {Number}  speed Scalar speed to add\n  * @param {Number}  angle Direction in degrees\n  */\n  this.addSpeed = function(speed, angle) {\n    var a;\n    if (pInst._angleMode === pInst.RADIANS) {\n      a = radians(angle);\n    } else {\n      a = angle;\n    }\n    this.velocity.x += cos(a) * speed;\n    this.velocity.y += sin(a) * speed;\n  };\n\n  /**\n  * Pushes the sprite toward a point.\n  * The force is added to the current velocity.\n  *\n  * @method attractionPoint\n  * @param {Number}  magnitude Scalar speed to add\n  * @param {Number}  pointX Direction x coordinate\n  * @param {Number}  pointY Direction y coordinate\n  */\n  this.attractionPoint = function(magnitude, pointX, pointY) {\n    var angle = atan2(pointY-this.position.y, pointX-this.position.x);\n    this.velocity.x += cos(angle) * magnitude;\n    this.velocity.y += sin(angle) * magnitude;\n  };\n\n\n  /**\n  * Adds an image to the sprite.\n  * An image will be considered a one-frame animation.\n  * The image should be preloaded in the preload() function using p5 loadImage.\n  * Animations require a identifying label (string) to change them.\n  * The image is stored in the sprite but not necessarily displayed\n  * until Sprite.changeAnimation(label) is called\n  *\n  * Usages:\n  * - sprite.addImage(label, image);\n  * - sprite.addImage(image);\n  *\n  * If only an image is passed no label is specified\n  *\n  * @method addImage\n  * @param {String|p5.Image} label Label or image\n  * @param {p5.Image} [img] Image\n  */\n  this.addImage = function()\n  {\n    if(typeof arguments[0] === 'string' && arguments[1] instanceof p5.Image)\n      this.addAnimation(arguments[0], arguments[1]);\n    else if(arguments[0] instanceof p5.Image)\n      this.addAnimation('normal', arguments[0]);\n    else\n      throw('addImage error: allowed usages are <image> or <label>, <image>');\n  };\n\n  /**\n  * Adds an animation to the sprite.\n  * The animation should be preloaded in the preload() function\n  * using loadAnimation.\n  * Animations require a identifying label (string) to change them.\n  * Animations are stored in the sprite but not necessarily displayed\n  * until Sprite.changeAnimation(label) is called.\n  *\n  * Usage:\n  * - sprite.addAnimation(label, animation);\n  *\n  * Alternative usages. See Animation for more information on file sequences:\n  * - sprite.addAnimation(label, firstFrame, lastFrame);\n  * - sprite.addAnimation(label, frame1, frame2, frame3...);\n  *\n  * @method addAnimation\n  * @param {String} label Animation identifier\n  * @param {Animation} animation The preloaded animation\n  */\n  this.addAnimation = function(label)\n  {\n    var anim;\n\n    if(typeof label !== 'string')\n    {\n      print('Sprite.addAnimation error: the first argument must be a label (String)');\n      return -1;\n    }\n    else if(arguments.length < 2)\n    {\n      print('addAnimation error: you must specify a label and n frame images');\n      return -1;\n    }\n    else if(arguments[1] instanceof Animation)\n    {\n\n      var sourceAnimation = arguments[1];\n\n      var newAnimation = sourceAnimation.clone();\n\n      animations[label] = newAnimation;\n\n      if(currentAnimation === '')\n      {\n        currentAnimation = label;\n        this.animation = newAnimation;\n      }\n\n      newAnimation.isSpriteAnimation = true;\n\n      this._internalWidth = newAnimation.getWidth()*abs(this._getScaleX());\n      this._internalHeight = newAnimation.getHeight()*abs(this._getScaleY());\n\n      return newAnimation;\n    }\n    else\n    {\n      var animFrames = [];\n      for(var i=1; i<arguments.length; i++)\n        animFrames.push(arguments[i]);\n\n      anim = construct(pInst.Animation, animFrames);\n      animations[label] = anim;\n\n      if(currentAnimation === '')\n      {\n        currentAnimation = label;\n        this.animation = anim;\n      }\n      anim.isSpriteAnimation = true;\n\n      this._internalWidth = anim.getWidth()*abs(this._getScaleX());\n      this._internalHeight = anim.getHeight()*abs(this._getScaleY());\n\n      return anim;\n    }\n\n  };\n\n  /**\n  * Changes the displayed image/animation.\n  * Equivalent to changeAnimation\n  *\n  * @method changeImage\n  * @param {String} label Image/Animation identifier\n  */\n  this.changeImage = function(label) {\n    this.changeAnimation(label);\n  };\n\n   /**\n  * Returns the label of the current animation\n  *\n  * @method getAnimationLabel\n  * @return {String} label Image/Animation identifier\n  */\n  this.getAnimationLabel = function() {\n    return currentAnimation;\n  };\n\n  /**\n  * Changes the displayed animation.\n  * See Animation for more control over the sequence.\n  *\n  * @method changeAnimation\n  * @param {String} label Animation identifier\n  */\n  this.changeAnimation = function(label) {\n    if(!animations[label])\n      print('changeAnimation error: no animation labeled '+label);\n    else\n    {\n      currentAnimation = label;\n      this.animation = animations[label];\n    }\n  };\n\n  /**\n  * Checks if the given point corresponds to a transparent pixel\n  * in the sprite's current image. It can be used to check a point collision\n  * against only the visible part of the sprite.\n  *\n  * @method overlapPixel\n  * @param {Number} pointX x coordinate of the point to check\n  * @param {Number} pointY y coordinate of the point to check\n  * @return {Boolean} result True if non-transparent\n  */\n  this.overlapPixel = function(pointX, pointY) {\n    var point = createVector(pointX, pointY);\n\n    var img = this.animation.getFrameImage();\n\n    //convert point to img relative position\n    point.x -= this.position.x-img.width/2;\n    point.y -= this.position.y-img.height/2;\n\n    //out of the image entirely\n    if(point.x<0 || point.x>img.width || point.y<0 || point.y>img.height)\n      return false;\n    else if(this.rotation === 0 && this.scale === 1)\n    {\n      //true if full opacity\n      var values = img.get(point.x, point.y);\n      return values[3] === 255;\n    }\n    else\n    {\n      print('Error: overlapPixel doesn\\'t work with scaled or rotated sprites yet');\n      //offscreen printing to be implemented bleurch\n      return false;\n    }\n  };\n\n  /**\n  * Checks if the given point is inside the sprite's collider.\n  *\n  * @method overlapPoint\n  * @param {Number} pointX x coordinate of the point to check\n  * @param {Number} pointY y coordinate of the point to check\n  * @return {Boolean} result True if inside\n  */\n  this.overlapPoint = function(pointX, pointY) {\n    var point = createVector(pointX, pointY);\n\n    if(!this.collider)\n      this.setDefaultCollider();\n\n    if(this.collider !== undefined)\n    {\n      if(this.collider instanceof AABB)\n        return (point.x > this.collider.left() && point.x < this.collider.right() && point.y > this.collider.top() && point.y < this.collider.bottom());\n      if(this.collider instanceof CircleCollider)\n      {\n        var sqRadius = this.collider.radius * this.collider.radius;\n        var sqDist = pow(this.collider.center.x - point.x, 2) + pow(this.collider.center.y - point.y, 2);\n        return sqDist<sqRadius;\n      }\n      else\n        return false;\n    }\n    else\n      return false;\n\n  };\n\n\n  /**\n  * Checks if the the sprite is overlapping another sprite or a group.\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * If the target is a group the function will be called for each single\n  * sprite overlapping. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.overlap(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method overlap\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  this.overlap = function(target, callback) {\n    //if(this.collider instanceof AABB && target.collider instanceof AABB)\n    return this.AABBops('overlap', target, callback);\n  };\n\n  /**\n  * Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the current sprite will be displace by\n  * the colliding one in the closest non-overlapping position.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.collide(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method collide\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  this.collide = function(target, callback) {\n    //if(this.collider instanceof AABB && target.collider instanceof AABB)\n    return this.AABBops('collide', target, callback);\n  };\n\n  /**\n  * Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the current sprite will displace\n  * the colliding one to the closest non-overlapping position.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.displace(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method displace\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  this.displace = function(target, callback) {\n    return this.AABBops('displace', target, callback);\n  };\n\n  /**\n  * Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the sprites will bounce affecting each\n  * other's trajectories depending on their .velocity, .mass and .restitution\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.bounce(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method bounce\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  this.bounce = function(target, callback) {\n    return this.AABBops('bounce', target, callback);\n  };\n\n  // Internal collision detection function. Do not use directly.\n  this.AABBops = function(type, target, callback) {\n\n    this.touching.left = false;\n    this.touching.right = false;\n    this.touching.top = false;\n    this.touching.bottom = false;\n\n    var result = false;\n\n    //if single sprite turn into array anyway\n    var others = [];\n\n    if(target instanceof Sprite)\n      others.push(target);\n    else if(target instanceof Array)\n    {\n      if(quadTree !== undefined && quadTree.active)\n        others = quadTree.retrieveFromGroup( this, target);\n\n      if(others.length === 0)\n        others = target;\n\n    }\n    else\n      throw('Error: overlap can only be checked between sprites or groups');\n\n    for(var i=0; i<others.length; i++)\n      if(this !== others[i] && !this.removed) //you can check collisions within the same group but not on itself\n      {\n        var displacement;\n        var other = others[i];\n\n        if(this.collider === undefined)\n          this.setDefaultCollider();\n\n        if(other.collider === undefined)\n          other.setDefaultCollider();\n\n        /*\n        if(this.colliderType==\"default\" && animations[currentAnimation]!=null)\n        {\n          print(\"busted\");\n          return false;\n        }*/\n        if(this.collider !== undefined && other.collider !== undefined)\n        {\n        if(type === 'overlap') {\n            var over;\n\n            //if the other is a circle I calculate the displacement from here\n            if(this.collider instanceof CircleCollider)\n                over = other.collider.overlap(this.collider);\n            else\n                over = this.collider.overlap(other.collider);\n\n            if(over)\n            {\n\n              result = true;\n\n              if(callback !== undefined && typeof callback === 'function')\n                callback.call(this, this, other);\n            }\n          }\n        else if(type === 'collide' || type === 'displace' || type === 'bounce')\n          {\n            displacement = createVector(0, 0);\n\n            //if the sum of the speed is more than the collider i may\n            //have a tunnelling problem\n            var tunnelX = abs(this.velocity.x-other.velocity.x) >= other.collider.extents.x/2 && round(this.deltaX - this.velocity.x) === 0;\n\n            var tunnelY = abs(this.velocity.y-other.velocity.y) >= other.collider.size().y/2 && round(this.deltaY - this.velocity.y) === 0;\n\n\n            if(tunnelX || tunnelY)\n            {\n              //instead of using the colliders I use the bounding box\n              //around the previous position and current position\n              //this is regardless of the collider type\n\n              //the center is the average of the coll centers\n              var c = createVector(\n                (this.position.x+this.previousPosition.x)/2,\n                (this.position.y+this.previousPosition.y)/2);\n\n              //the extents are the distance between the coll centers\n              //plus the extents of both\n              var e = createVector(\n                abs(this.position.x -this.previousPosition.x) + this.collider.extents.x,\n                abs(this.position.y -this.previousPosition.y) + this.collider.extents.y);\n\n              var bbox = new AABB(pInst, c, e, this.collider.offset);\n\n              //bbox.draw();\n\n              if(bbox.overlap(other.collider))\n              {\n                if(tunnelX) {\n\n                  //entering from the right\n                  if(this.velocity.x < 0)\n                    displacement.x = other.collider.right() - this.collider.left() + 1;\n                  else if(this.velocity.x > 0 )\n                    displacement.x = other.collider.left() - this.collider.right() -1;\n                  }\n\n                if(tunnelY) {\n                  //from top\n                  if(this.velocity.y > 0)\n                    displacement.y = other.collider.top() - this.collider.bottom() - 1;\n                  else if(this.velocity.y < 0 )\n                    displacement.y = other.collider.bottom() - this.collider.top() + 1;\n\n                  }\n\n              }//end overlap\n\n            }\n            else //non tunnel overlap\n            {\n\n              //if the other is a circle I calculate the displacement from here\n              //and reverse it\n              if(this.collider instanceof CircleCollider)\n                {\n                displacement = other.collider.collide(this.collider).mult(-1);\n                }\n              else\n                displacement = this.collider.collide(other.collider);\n\n            }\n\n            if(displacement.x !== 0 || displacement.y !== 0)\n            {\n              var newVelX1, newVelY1, newVelX2, newVelY2;\n\n              if (type === 'displace' && !other.immovable) {\n                other.position.sub(displacement);\n              } else if ((type === 'collide' || type === 'bounce') && !this.immovable) {\n                this.position.add(displacement);\n                this.previousPosition = createVector(this.position.x, this.position.y);\n                this.newPosition = createVector(this.position.x, this.position.y);\n              }\n\n              if(displacement.x > 0)\n                this.touching.left = true;\n              if(displacement.x < 0)\n                this.touching.right = true;\n              if(displacement.y < 0)\n                this.touching.bottom = true;\n              if(displacement.y > 0)\n                this.touching.top = true;\n\n              if(type === 'bounce')\n              {\n                if (this.collider instanceof CircleCollider && other.collider instanceof CircleCollider) {\n                  var dx1 = p5.Vector.sub(this.position, other.position);\n                  var dx2 = p5.Vector.sub(other.position, this.position);\n                  var magnitude = dx1.magSq();\n                  var totalMass = this.mass + other.mass;\n                  var m1 = 0, m2 = 0;\n                  if (this.immovable) {\n                    m2 = 2;\n                  } else if (other.immovable) {\n                    m1 = 2;\n                  } else {\n                    m1 = 2 * other.mass / totalMass;\n                    m2 = 2 * this.mass / totalMass;\n                  }\n                  var newVel1 = dx1.mult(m1 * p5.Vector.sub(this.velocity, other.velocity).dot(dx1) / magnitude);\n                  var newVel2 = dx2.mult(m2 * p5.Vector.sub(other.velocity, this.velocity).dot(dx2) / magnitude);\n\n                  this.velocity.sub(newVel1.mult(this.restitution));\n                  other.velocity.sub(newVel2.mult(other.restitution));\n                }\n                else {\n                if(other.immovable)\n                {\n                  newVelX1 = -this.velocity.x+other.velocity.x;\n                  newVelY1 = -this.velocity.y+other.velocity.y;\n                }\n                else\n                {\n                  newVelX1 = (this.velocity.x * (this.mass - other.mass) + (2 * other.mass * other.velocity.x)) / (this.mass + other.mass);\n                  newVelY1 = (this.velocity.y * (this.mass - other.mass) + (2 * other.mass * other.velocity.y)) / (this.mass + other.mass);\n                  newVelX2 = (other.velocity.x * (other.mass - this.mass) + (2 * this.mass * this.velocity.x)) / (this.mass + other.mass);\n                  newVelY2 = (other.velocity.y * (other.mass - this.mass) + (2 * this.mass * this.velocity.y)) / (this.mass + other.mass);\n                }\n\n                //var bothCircles = (this.collider instanceof CircleCollider &&\n                //                   other.collider  instanceof CircleCollider);\n\n                //if(this.touching.left || this.touching.right || this.collider instanceof CircleCollider)\n\n                //print(displacement);\n\n                if(abs(displacement.x)>abs(displacement.y))\n                {\n\n\n                  if(!this.immovable)\n                  {\n                    this.velocity.x = newVelX1*this.restitution;\n\n                  }\n\n                  if(!other.immovable)\n                    other.velocity.x = newVelX2*other.restitution;\n\n                }\n                //if(this.touching.top || this.touching.bottom || this.collider instanceof CircleCollider)\n                if(abs(displacement.x)<abs(displacement.y))\n                {\n\n                  if(!this.immovable)\n                    this.velocity.y = newVelY1*this.restitution;\n\n                  if(!other.immovable)\n                    other.velocity.y = newVelY2*other.restitution;\n                }\n                }\n              }\n              //else if(type == \"collide\")\n                //this.velocity = createVector(0,0);\n\n              if(callback !== undefined && typeof callback === 'function')\n                callback.call(this, this, other);\n\n              result = true;\n            }\n          }\n        }//end collider exists\n      }\n\n    return result;\n  };\n} //end Sprite class\n\ndefineLazyP5Property('Sprite', boundConstructorFactory(Sprite));\n\n/**\n   * A camera facilitates scrolling and zooming for scenes extending beyond\n   * the canvas. A camera has a position, a zoom factor, and the mouse\n   * coordinates relative to the view.\n   * The camera is automatically created on the first draw cycle.\n   *\n   * In p5.js terms the camera wraps the whole drawing cycle in a\n   * transformation matrix but it can be disable anytime during the draw\n   * cycle for example to draw interface elements in an absolute position.\n   *\n   * @class Camera\n   * @constructor\n   * @param {Number} x Initial x coordinate\n   * @param {Number} y Initial y coordinate\n   * @param {Number} zoom magnification\n   **/\nfunction Camera(pInst, x, y, zoom) {\n  /**\n  * Camera position. Defines the global offset of the sketch.\n  *\n  * @property position\n  * @type {p5.Vector}\n  */\n  this.position = pInst.createVector(x, y);\n\n  /**\n  * Camera zoom. Defines the global scale of the sketch.\n  * A scale of 1 will be the normal size. Setting it to 2 will make everything\n  * twice the size. .5 will make everything half size.\n  *\n  * @property zoom\n  * @type {Number}\n  */\n  this.zoom = zoom;\n\n  /**\n  * MouseX translated to the camera view.\n  * Offsetting and scaling the canvas will not change the sprites' position\n  * nor the mouseX and mouseY variables. Use this property to read the mouse\n  * position if the camera moved or zoomed.\n  *\n  * @property mouseX\n  * @type {Number}\n  */\n  this.mouseX = pInst.mouseX;\n\n  /**\n  * MouseY translated to the camera view.\n  * Offsetting and scaling the canvas will not change the sprites' position\n  * nor the mouseX and mouseY variables. Use this property to read the mouse\n  * position if the camera moved or zoomed.\n  *\n  * @property mouseY\n  * @type {Number}\n  */\n  this.mouseY = pInst.mouseY;\n\n  /**\n  * True if the camera is active.\n  * Read only property. Use the methods Camera.on() and Camera.off()\n  * to enable or disable the camera.\n  *\n  * @property active\n  * @type {Boolean}\n  */\n  this.active = false;\n\n  /**\n  * Activates the camera.\n  * The canvas will be drawn according to the camera position and scale until\n  * Camera.off() is called\n  *\n  * @method on\n  */\n  this.on = function() {\n    if(!this.active)\n    {\n      cameraPush.call(pInst);\n      this.active = true;\n    }\n  };\n\n  /**\n  * Deactivates the camera.\n  * The canvas will be drawn normally, ignoring the camera's position\n  * and scale until Camera.on() is called\n  *\n  * @method off\n  */\n  this.off = function() {\n    if(this.active)\n    {\n      cameraPop.call(pInst);\n      this.active = false;\n    }\n  };\n} //end camera class\n\ndefineLazyP5Property('Camera', boundConstructorFactory(Camera));\n\n//called pre draw by default\nfunction cameraPush() {\n  var pInst = this;\n  var camera = pInst.camera;\n\n  //awkward but necessary in order to have the camera at the center\n  //of the canvas by default\n  if(!camera.init && camera.position.x === 0 && camera.position.y === 0)\n    {\n    camera.position.x=pInst.width/2;\n    camera.position.y=pInst.height/2;\n    camera.init = true;\n    }\n\n  camera.mouseX = pInst.mouseX+camera.position.x-pInst.width/2;\n  camera.mouseY = pInst.mouseY+camera.position.y-pInst.height/2;\n\n  if(!camera.active)\n  {\n    camera.active = true;\n    pInst.push();\n    pInst.scale(camera.zoom);\n    pInst.translate(-camera.position.x+pInst.width/2/camera.zoom, -camera.position.y+pInst.height/2/camera.zoom);\n  }\n}\n\n//called postdraw by default\nfunction cameraPop() {\n  var pInst = this;\n\n  if(pInst.camera.active)\n  {\n    pInst.pop();\n    pInst.camera.active = false;\n  }\n}\n\n\n\n\n/**\n   * In p5.play groups are collections of sprites with similar behavior.\n   * For example a group may contain all the sprites in the background\n   * or all the sprites that \"kill\" the player.\n   *\n   * Groups are \"extended\" arrays and inherit all their properties\n   * e.g. group.length\n   *\n   * Since groups contain only references, a sprite can be in multiple\n   * groups and deleting a group doesn't affect the sprites themselves.\n   *\n   * Sprite.remove() will also remove the sprite from all the groups\n   * it belongs to.\n   *\n   * @class Group\n   * @constructor\n   */\nfunction Group() {\n\n  //basically extending the array\n  var array = [];\n\n  /**\n  * Gets the member at index i.\n  *\n  * @method get\n  * @param {Number} i The index of the object to retrieve\n  */\n  array.get = function(i) {\n    return array[i];\n  };\n\n  /**\n  * Checks if the group contains a sprite.\n  *\n  * @method contains\n  * @param {Sprite} sprite The sprite to search\n  * @return {Number} Index or -1 if not found\n  */\n  array.contains = function(sprite) {\n    return this.indexOf(sprite)>-1;\n  };\n\n  /**\n   * Same as Group.contains\n   * @method indexOf\n   */\n  array.indexOf = function(item) {\n    for (var i = 0, len = array.length; i < len; ++i) {\n      if (virtEquals(item, array[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n  * Adds a sprite to the group.\n  *\n  * @method add\n  * @param {Sprite} s The sprite to be added\n  */\n  array.add = function(s) {\n    if(!(s instanceof Sprite)) {\n      throw('Error: you can only add sprites to a group');\n    }\n\n    if (-1 === this.indexOf(s)) {\n      array.push(s);\n      s.groups.push(this);\n    }\n  };\n\n  /**\n   * Same as group.length\n   * @method size\n   */\n  array.size = function() {\n    return array.length;\n  };\n\n  /**\n  * Removes all the sprites in the group\n  * from the scene.\n  *\n  * @method removeSprites\n  */\n  array.removeSprites = function() {\n    while (array.length > 0) {\n      array[0].remove();\n    }\n  };\n\n  /**\n  * Removes all references to the group.\n  * Does not remove the actual sprites.\n  *\n  * @method clear\n  */\n  array.clear = function() {\n    array.length = 0;\n  };\n\n  /**\n  * Removes a sprite from the group.\n  * Does not remove the actual sprite, only the affiliation (reference).\n  *\n  * @method remove\n  * @param {Sprite} item The sprite to be removed\n  * @return {Boolean} True if sprite was found and removed\n  */\n  array.remove = function(item) {\n    if(!(item instanceof Sprite)) {\n      throw('Error: you can only remove sprites from a group');\n    }\n\n    var i, removed = false;\n    for (i = array.length - 1; i >= 0; i--) {\n      if (array[i] === item) {\n        array.splice(i, 1);\n        removed = true;\n      }\n    }\n\n    if (removed) {\n      for (i = item.groups.length - 1; i >= 0; i--) {\n        if (item.groups[i] === this) {\n          item.groups.splice(i, 1);\n        }\n      }\n    }\n\n    return removed;\n  };\n\n  /**\n   * Returns a copy of the group as standard array.\n   * @method toArray\n   */\n  array.toArray = function() {\n    return array.slice(0);\n  };\n\n  /**\n  * Returns the highest depth in a group\n  *\n  * @method maxDepth\n  * @return {Number} The depth of the sprite drawn on the top\n  */\n  array.maxDepth = function() {\n    if (array.length === 0) {\n      return 0;\n    }\n\n    return array.reduce(function(maxDepth, sprite) {\n      return Math.max(maxDepth, sprite.depth);\n    }, -Infinity);\n  };\n\n  /**\n  * Returns the lowest depth in a group\n  *\n  * @method minDepth\n  * @return {Number} The depth of the sprite drawn on the bottom\n  */\n  array.minDepth = function() {\n    if (array.length === 0) {\n      return 99999;\n    }\n\n    return array.reduce(function(minDepth, sprite) {\n      return Math.min(minDepth, sprite.depth);\n    }, Infinity);\n  };\n\n  /**\n  * Draws all the sprites in the group.\n  *\n  * @method draw\n  */\n  array.draw = function() {\n\n    //sort by depth\n    this.sort(function(a, b) {\n      return a.depth - b.depth;\n    });\n\n    for(var i = 0; i<this.size(); i++)\n    {\n      this.get(i).display();\n    }\n  };\n\n  //internal use\n  function virtEquals(obj, other) {\n    if (obj === null || other === null) {\n      return (obj === null) && (other === null);\n    }\n    if (typeof (obj) === 'string') {\n      return obj === other;\n    }\n    if (typeof(obj) !== 'object') {\n      return obj === other;\n    }\n    if (obj.equals instanceof Function) {\n      return obj.equals(other);\n    }\n    return obj === other;\n  }\n\n  /**\n   * Collide each member of group against the target using the given collision\n   * type.  Return true if any collision occurred.\n   * Internal use\n   *\n   * @private\n   * @method _groupCollide\n   * @param {!string} type one of 'overlap', 'collide', 'displace', 'bounce'\n   * @param {Object} target Group or Sprite\n   * @param {Function} [callback] on collision.\n   * @return {boolean} True if any collision/overlap occurred\n   */\n  function _groupCollide(type, target, callback) {\n    var didCollide = false;\n    for(var i = 0; i<this.size(); i++)\n      didCollide = this.get(i).AABBops(type, target, callback) || didCollide;\n    return didCollide;\n  }\n\n  /**\n  * Checks if the the group is overlapping another group or sprite.\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occurs.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.overlap(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method overlap\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  array.overlap = _groupCollide.bind(array, 'overlap');\n\n\n  /**\n  * Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites in the group will be displaced\n  * by the colliding one to the closest non-overlapping positions.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.collide(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method collide\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  array.collide = _groupCollide.bind(array, 'collide');\n\n  /**\n  * Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites in the group will displace\n  * the colliding ones to the closest non-overlapping positions.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occurs.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.displace(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method displace\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  array.displace = _groupCollide.bind(array, 'displace');\n\n  /**\n  * Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites will bounce affecting each\n  * other's trajectories depending on their .velocity, .mass and .restitution.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.bounce(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method bounce\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping\n  */\n  array.bounce = _groupCollide.bind(array, 'bounce');\n\n  return array;\n}\n\np5.prototype.Group = Group;\n\n//circle collider - used internally\nfunction CircleCollider(pInst, _center, _radius, _offset) {\n  var pInstBind = createPInstBinder(pInst);\n\n  var createVector = pInstBind('createVector');\n\n  var CENTER = p5.prototype.CENTER;\n\n  this.center = _center;\n  this.radius = _radius;\n  this.originalRadius = _radius;\n\n  if(_offset === undefined)\n    this.offset = createVector(0, 0);\n  else\n    this.offset = _offset;\n  this.extents = createVector(_radius*2, _radius*2);\n\n  this.draw = function()\n  {\n    pInst.noFill();\n    pInst.stroke(0, 255, 0);\n    pInst.rectMode(CENTER);\n    pInst.ellipse(this.center.x+this.offset.x, this.center.y+this.offset.y, this.radius*2, this.radius*2);\n  };\n\n  //should be called only for circle vs circle\n  this.overlap = function(other)\n  {\n    //square dist\n    var r = this.radius + other.radius;\n    r *= r;\n    var thisCenterX = this.center.x + this.offset.x;\n    var thisCenterY = this.center.y + this.offset.y;\n    var otherCenterX = other.center.x + other.offset.x;\n    var otherCenterY = other.center.y + other.offset.y;\n    var sqDist = pow(thisCenterX - otherCenterX, 2) + pow(thisCenterY - otherCenterY, 2);\n    return r > sqDist;\n  };\n\n  //should be called only for circle vs circle\n  this.collide = function(other)\n  {\n    if(this.overlap(other)) {\n      var thisCenterX = this.center.x + this.offset.x;\n      var thisCenterY = this.center.y + this.offset.y;\n      var otherCenterX = other.center.x + other.offset.x;\n      var otherCenterY = other.center.y + other.offset.y;\n      var a = pInst.atan2(thisCenterY-otherCenterY, thisCenterX-otherCenterX);\n      var radii = this.radius+other.radius;\n      var intersection = abs(radii - dist(thisCenterX, thisCenterY, otherCenterX, otherCenterY));\n\n      var displacement = createVector(pInst.cos(a)*intersection, pInst.sin(a)*intersection);\n\n      return displacement;\n    } else {\n      return createVector(0, 0);\n    }\n  };\n\n  this.size = function()\n  {\n    return createVector(this.radius*2, this.radius*2);\n  };\n\n  this.left = function()\n  {\n    return this.center.x+this.offset.x - this.radius;\n  };\n\n  this.right = function()\n  {\n    return this.center.x+this.offset.x + this.radius;\n  };\n\n  this.top = function()\n  {\n    return this.center.y+this.offset.y - this.radius;\n  };\n\n  this.bottom = function()\n  {\n    return this.center.y+this.offset.y + this.radius;\n  };\n\n\n\n}\ndefineLazyP5Property('CircleCollider', boundConstructorFactory(CircleCollider));\n\n//axis aligned bounding box - extents are the half sizes - used internally\nfunction AABB(pInst, _center, _extents, _offset) {\n  var pInstBind = createPInstBinder(pInst);\n\n  var createVector = pInstBind('createVector');\n\n  var CENTER = p5.prototype.CENTER;\n  var PI = p5.prototype.PI;\n\n  this.center = _center;\n  this.extents = _extents;\n  this.originalExtents = _extents.copy();\n\n  if(_offset === undefined)\n    this.offset = createVector(0, 0);\n  else\n    this.offset = _offset;\n\n  this.min = function()\n  {\n    return createVector(this.center.x+this.offset.x - this.extents.x, this.center.y+this.offset.y - this.extents.y);\n  };\n\n  this.max = function()\n  {\n    return createVector(this.center.x+this.offset.x + this.extents.x, this.center.y+this.offset.y + this.extents.y);\n  };\n\n  this.right = function()\n  {\n    return this.center.x+this.offset.x + this.extents.x/2;\n  };\n\n  this.left = function()\n  {\n    return this.center.x+this.offset.x - this.extents.x/2;\n  };\n\n  this.top = function()\n  {\n    return this.center.y+this.offset.y - this.extents.y/2;\n  };\n\n  this.bottom = function()\n  {\n    return this.center.y+this.offset.y + this.extents.y/2;\n  };\n\n  this.size = function()\n  {\n    return createVector(this.extents.x * 2, this.extents.y * 2);\n  };\n\n  this.rotate = function(r)\n  {\n    //rotate the bbox\n    var t;\n    if (pInst._angleMode === pInst.RADIANS) {\n      t = radians(r);\n    } else {\n      t = r;\n    }\n\n    var w2 = this.extents.x * abs(pInst.cos(t)) + this.extents.y * abs(pInst.sin(t));\n    var h2 = this.extents.x * abs(pInst.sin(t)) + this.extents.y * abs(pInst.cos(t));\n\n    this.extents.x = w2;\n    this.extents.y = h2;\n\n  };\n\n  this.draw = function()\n  {\n    //fill(col);\n    pInst.noFill();\n    pInst.stroke(0, 255, 0);\n    pInst.rectMode(CENTER);\n    pInst.rect(this.center.x+this.offset.x, this.center.y+this.offset.y, this.size().x/2, this.size().y/2);\n  };\n\n  this.overlap = function(other)\n  {\n    //box vs box\n    if(other instanceof AABB)\n    {\n      var md = other.minkowskiDifference(this);\n\n      if (md.min().x <= 0 &&\n          md.max().x >= 0 &&\n          md.min().y <= 0 &&\n          md.max().y >= 0)\n      {\n        return true;\n      }\n      else\n        return false;\n    }\n    //box vs circle\n    else if(other instanceof CircleCollider)\n    {\n\n      //find closest point to the circle on the box\n      var pt = createVector(other.center.x, other.center.y);\n\n      //I don't know what's going o try to trace a line from centers to see\n      if( other.center.x < this.left() )\n        pt.x = this.left();\n      else if( other.center.x > this.right())\n        pt.x = this.right();\n\n      if( other.center.y < this.top() )\n        pt.y = this.top();\n      else if( other.center.y > this.bottom())\n        pt.y = this.bottom();\n\n      var distance = pt.dist(other.center);\n\n      return distance<other.radius;\n    }\n  };\n\n  this.collide = function(other)\n  {\n\n    if(other instanceof AABB)\n    {\n      var md = other.minkowskiDifference(this);\n\n      if (md.min().x <= 0 &&\n          md.max().x >= 0 &&\n          md.min().y <= 0 &&\n          md.max().y >= 0)\n      {\n        var boundsPoint = md.closestPointOnBoundsToPoint(createVector(0, 0));\n\n        return boundsPoint;\n      }\n      else\n        return createVector(0, 0);\n    }\n    //box vs circle\n    else if(other instanceof CircleCollider)\n    {\n\n      //find closest point to the circle on the box\n      var pt = createVector(other.center.x, other.center.y);\n\n      //I don't know what's going o try to trace a line from centers to see\n      if( other.center.x < this.left() )\n        pt.x = this.left();\n      else if( other.center.x > this.right())\n        pt.x = this.right();\n\n      if( other.center.y < this.top() )\n        pt.y = this.top();\n      else if( other.center.y > this.bottom())\n        pt.y = this.bottom();\n\n\n      var distance = pt.dist(other.center);\n      var a;\n\n      if(distance<other.radius)\n      {\n        //reclamp point\n        if(pt.x === other.center.x && pt.y === other.center.y)\n        {\n          var xOverlap = pt.x - this.center.x;\n          var yOverlap = pt.y - this.center.y;\n\n\n          if(abs(xOverlap) < abs(yOverlap))\n          {\n            if(xOverlap > 0 )\n              pt.x = this.right();\n            else\n              pt.x = this.left();\n          }\n          else\n          {\n            if(yOverlap < 0 )\n              pt.y = this.top();\n            else\n              pt.y = this.bottom();\n          }\n\n          a = pInst.atan2(other.center.y-pt.y, other.center.x-pt.x);\n\n          //fix exceptions\n          if(a === 0)\n          {\n            if(pt.x === this.right()) a = PI;\n            if(pt.y === this.top()) a = PI/2;\n            if(pt.y === this.bottom()) a = -PI/2;\n          }\n        }\n        else\n        {\n          //angle bw point and center\n          a = pInst.atan2(pt.y-other.center.y, pt.x-other.center.x);\n          //project the normal (line between pt and center) onto the circle\n        }\n\n        var d = createVector(pt.x-other.center.x, pt.y-other.center.y);\n        var displacement = createVector(pInst.cos(a)*other.radius-d.x, pInst.sin(a)*other.radius-d.y);\n\n        //if(pt.x === other.center.x && pt.y === other.center.y)\n        //displacement = displacement.mult(-1);\n\n        return displacement;\n        //return createVector(0,0);\n      }\n      else\n        return createVector(0, 0);\n    }\n  };\n\n  this.minkowskiDifference = function(other)\n  {\n    var topLeft = this.min().sub(other.max());\n    var fullSize = this.size().add(other.size());\n    return new AABB(pInst, topLeft.add(fullSize.div(2)), fullSize.div(2));\n  };\n\n\n  this.closestPointOnBoundsToPoint = function(point)\n  {\n    // test x first\n    var minDist = abs(point.x - this.min().x);\n    var boundsPoint = createVector(this.min().x, point.y);\n\n    if (abs(this.max().x - point.x) < minDist)\n    {\n      minDist = abs(this.max().x - point.x);\n      boundsPoint = createVector(this.max().x, point.y);\n    }\n\n    if (abs(this.max().y - point.y) < minDist)\n    {\n      minDist = abs(this.max().y - point.y);\n      boundsPoint = createVector(point.x, this.max().y);\n    }\n\n    if (abs(this.min().y - point.y) < minDist)\n    {\n      minDist = abs(this.min.y - point.y);\n      boundsPoint = createVector(point.x, this.min().y);\n    }\n\n    return boundsPoint;\n  };\n\n\n}//end AABB\ndefineLazyP5Property('AABB', boundConstructorFactory(AABB));\n\n\n\n/**\n * An Animation object contains a series of images (p5.Image) that\n * can be displayed sequentially.\n *\n * All files must be png images. You must include the directory from the sketch root,\n * and the extension .png\n *\n * A sprite can have multiple labeled animations, see Sprite.addAnimation\n * and Sprite.changeAnimation, however an animation can be used independently.\n *\n * An animation can be created either by passing a series of file names,\n * no matter how many or by passing the first and the last file name\n * of a numbered sequence.\n * p5.play will try to detect the sequence pattern.\n *\n * For example if the given filenames are\n * \"data/file0001.png\" and \"data/file0005.png\" the images\n * \"data/file0003.png\" and \"data/file0004.png\" will be loaded as well.\n *\n * @example\n *     var sequenceAnimation;\n *     var glitch;\n *\n *     function preload() {\n *       sequenceAnimation = loadAnimation(\"data/walking0001.png\", \"data/walking0005.png\");\n *       glitch = loadAnimation(\"data/dog.png\", \"data/horse.png\", \"data/cat.png\", \"data/snake.png\");\n *     }\n *\n *     function setup() {\n *       createCanvas(800, 600);\n *     }\n *\n *     function draw() {\n *       background(0);\n *       animation(sequenceAnimation, 100, 100);\n *       animation(glitch, 200, 100);\n *     }\n *\n * @class Animation\n * @constructor\n * @param {String} fileName1 First file in a sequence OR first image file\n * @param {String} fileName2 Last file in a sequence OR second image file\n * @param {String} [...fileNameN] Any number of image files after the first two\n */\nfunction Animation(pInst) {\n  var frameArguments = Array.prototype.slice.call(arguments, 1);\n  var i;\n\n  var CENTER = p5.prototype.CENTER;\n\n  /**\n  * Array of frames (p5.Image)\n  *\n  * @property images\n  * @type {Array}\n  */\n  this.images = [];\n\n  var frame = 0;\n  var cycles = 0;\n  var targetFrame = -1;\n\n  this.offX = 0;\n  this.offY = 0;\n\n  /**\n  * Delay between frames in number of draw cycles.\n  * If set to 4 the framerate of the animation would be the\n  * sketch framerate divided by 4 (60fps = 15fps)\n  *\n  * @property frameDelay\n  * @type {Number}\n  * @default 4\n  */\n  this.frameDelay = 4;\n\n  /**\n  * True if the animation is currently playing.\n  *\n  * @property playing\n  * @type {Boolean}\n  * @default true\n  */\n  this.playing = true;\n\n  /**\n  * Animation visibility.\n  *\n  * @property visible\n  * @type {Boolean}\n  * @default true\n  */\n  this.visible = true;\n\n  /**\n  * If set to false the animation will stop after reaching the last frame\n  *\n  * @property looping\n  * @type {Boolean}\n  * @default true\n  */\n  this.looping = true;\n\n  /**\n  * True if frame changed during the last draw cycle\n  *\n  * @property frameChanged\n  * @type {Boolean}\n  */\n  this.frameChanged = false;\n\n  //is the collider defined manually or defined\n  //by the current frame size\n  this.imageCollider = false;\n\n\n  //sequence mode\n  if(frameArguments.length === 2 && typeof frameArguments[0] === 'string' && typeof frameArguments[1] === 'string')\n  {\n    var from = frameArguments[0];\n    var to = frameArguments[1];\n\n    //print(\"sequence mode \"+from+\" -> \"+to);\n\n    //make sure the extensions are fine\n    var ext1 = from.substring(from.length-4, from.length);\n    if(ext1 !== '.png')\n    {\n      pInst.print('Animation error: you need to use .png files (filename '+from+')');\n      from = -1;\n    }\n\n    var ext2 = to.substring(to.length-4, to.length);\n    if(ext2 !== '.png')\n    {\n      pInst.print('Animation error: you need to use .png files (filename '+to+')');\n      to = -1;\n    }\n\n    //extensions are fine\n    if(from !== -1 && to !== -1)\n    {\n      var digits1 = 0;\n      var digits2 = 0;\n\n      //skip extension work backwards to find the numbers\n      for (i = from.length-5; i >= 0; i--) {\n        if(from.charAt(i) >= '0' && from.charAt(i) <= '9')\n          digits1++;\n      }\n\n      for (i = to.length-5; i >= 0; i--) {\n        if(to.charAt(i) >= '0' && to.charAt(i) <= '9')\n          digits2++;\n      }\n\n      var prefix1 = from.substring(0, from.length-(4+digits1));\n      var prefix2 = to.substring(0, to.length-(4+digits2) );\n\n      // Our numbers likely have leading zeroes, which means that some\n      // browsers (e.g., PhantomJS) will interpret them as base 8 (octal)\n      // instead of decimal. To fix this, we'll explicity tell parseInt to\n      // use a base of 10 (decimal). For more details on this issue, see\n      // http://stackoverflow.com/a/8763427/2422398.\n      var number1 = parseInt(from.substring(from.length-(4+digits1), from.length-4), 10);\n      var number2 = parseInt(to.substring(to.length-(4+digits2), to.length-4), 10);\n\n      //swap if inverted\n      if(number2<number1)\n      {\n        var t = number2;\n        number2 = number1;\n        number1 = t;\n      }\n\n      //two different frames\n      if(prefix1 !== prefix2 )\n      {\n        //print(\"2 separate images\");\n        this.images.push(pInst.loadImage(from));\n        this.images.push(pInst.loadImage(to));\n      }\n      //same digits: case img0001, img0002\n      else\n      {\n        var fileName;\n        if(digits1 === digits2)\n        {\n\n          //load all images\n          for (i = number1; i <= number2; i++) {\n            // Use nf() to number format 'i' into four digits\n            fileName = prefix1 + pInst.nf(i, digits1) + '.png';\n            this.images.push(pInst.loadImage(fileName));\n\n          }\n\n        }\n        else //case: case img1, img2\n        {\n          //print(\"from \"+prefix1+\" \"+number1 +\" to \"+number2);\n          for (i = number1; i <= number2; i++) {\n            // Use nf() to number format 'i' into four digits\n            fileName = prefix1 + i + '.png';\n            this.images.push(pInst.loadImage(fileName));\n\n          }\n\n        }\n      }\n\n    }//end no ext error\n\n  }//end sequence mode\n  // Sprite sheet mode\n  else if (frameArguments.length === 1 && (frameArguments[0] instanceof SpriteSheet))\n  {\n    this.spriteSheet = frameArguments[0];\n    this.images = this.spriteSheet.frames;\n  }\n  else if(frameArguments.length !== 0)//arbitrary list of images\n  {\n    //print(\"Animation arbitrary mode\");\n    for (i = 0; i < frameArguments.length; i++) {\n      //print(\"loading \"+fileNames[i]);\n      if(frameArguments[i] instanceof p5.Image)\n        this.images.push(frameArguments[i]);\n      else\n        this.images.push(pInst.loadImage(frameArguments[i]));\n    }\n  }\n\n  /**\n  * Objects are passed by reference so to have different sprites\n  * using the same animation you need to clone it.\n  *\n  * @method clone\n  * @return {Animation} A clone of the current animation\n  */\n  this.clone = function() {\n    var myClone = new Animation(pInst); //empty\n    myClone.images = [];\n\n    if (this.spriteSheet) {\n      myClone.spriteSheet = this.spriteSheet.clone();\n    }\n    myClone.images = this.images.slice();\n\n    myClone.offX = this.offX;\n    myClone.offY = this.offY;\n    myClone.frameDelay = this.frameDelay;\n    myClone.playing = this.playing;\n    myClone.looping = this.looping;\n\n    return myClone;\n  };\n\n  /**\n   * Draws the animation at coordinate x and y.\n   * Updates the frames automatically.\n   *\n   * @method draw\n   * @param {Number} x x coordinate\n   * @param {Number} y y coordinate\n   * @param {Number} [r=0] rotation\n   */\n  this.draw = function(x, y, r) {\n    this.xpos = x;\n    this.ypos = y;\n    this.rotation = r || 0;\n\n    if (this.visible)\n    {\n\n      //only connection with the sprite class\n      //if animation is used independently draw and update are the sam\n      if(!this.isSpriteAnimation)\n        this.update();\n\n      //this.currentImageMode = g.imageMode;\n      pInst.push();\n      pInst.imageMode(CENTER);\n\n      pInst.translate(this.xpos, this.ypos);\n      if (pInst._angleMode === pInst.RADIANS) {\n        pInst.rotate(radians(this.rotation));\n      } else {\n        pInst.rotate(this.rotation);\n      }\n\n      if(this.images[frame] !== undefined)\n      {\n        if (this.spriteSheet) {\n          var frame_info = this.images[frame].frame;\n          pInst.image(this.spriteSheet.image, frame_info.x, frame_info.y, frame_info.width,\n            frame_info.height, this.offX, this.offY, frame_info.width, frame_info.height);\n        } else {\n          pInst.image(this.images[frame], this.offX, this.offY);\n        }\n      }\n      else\n      {\n        pInst.print('Warning undefined frame '+frame);\n        //this.isActive = false;\n      }\n\n      pInst.pop();\n    }\n  };\n\n  //called by draw\n  this.update = function() {\n    cycles++;\n    var previousFrame = frame;\n    this.frameChanged = false;\n\n\n    //go to frame\n    if(this.images.length === 1)\n    {\n      this.playing = false;\n      frame = 0;\n    }\n\n    if ( this.playing && cycles%this.frameDelay === 0)\n    {\n      //going to target frame up\n      if(targetFrame>frame && targetFrame !== -1)\n      {\n        frame++;\n      }\n      //going to taget frame down\n      else if(targetFrame<frame && targetFrame !== -1)\n      {\n        frame--;\n      }\n      else if(targetFrame === frame && targetFrame !== -1)\n      {\n        this.playing=false;\n      }\n      else if (this.looping) //advance frame\n      {\n        //if next frame is too high\n        if (frame>=this.images.length-1)\n          frame = 0;\n        else\n          frame++;\n      } else\n      {\n        //if next frame is too high\n        if (frame<this.images.length-1)\n          frame++;\n      }\n    }\n\n    if(previousFrame !== frame)\n      this.frameChanged = true;\n\n  };//end update\n\n  /**\n  * Plays the animation.\n  *\n  * @method play\n  */\n  this.play = function() {\n    this.playing = true;\n    targetFrame = -1;\n  };\n\n  /**\n  * Stops the animation.\n  *\n  * @method stop\n  */\n  this.stop = function(){\n    this.playing = false;\n  };\n\n  /**\n  * Rewinds the animation to the first frame.\n  *\n  * @method rewind\n  */\n  this.rewind = function() {\n    frame = 0;\n  };\n\n  /**\n  * Changes the current frame.\n  *\n  * @method changeFrame\n  * @param {Number} frame Frame number (starts from 0).\n  */\n  this.changeFrame = function(f) {\n    if (f<this.images.length)\n      frame = f;\n    else\n      frame = this.images.length - 1;\n\n    targetFrame = -1;\n    //this.playing = false;\n  };\n\n   /**\n  * Goes to the next frame and stops.\n  *\n  * @method nextFrame\n  */\n  this.nextFrame = function() {\n\n    if (frame<this.images.length-1)\n      frame = frame+1;\n    else if(this.looping)\n      frame = 0;\n\n    targetFrame = -1;\n    this.playing = false;\n  };\n\n   /**\n  * Goes to the previous frame and stops.\n  *\n  * @method previousFrame\n  */\n  this.previousFrame = function() {\n\n    if (frame>0)\n      frame = frame-1;\n    else if(this.looping)\n      frame = this.images.length-1;\n\n    targetFrame = -1;\n    this.playing = false;\n  };\n\n  /**\n  * Plays the animation forward or backward toward a target frame.\n  *\n  * @method goToFrame\n  * @param {Number} toFrame Frame number destination (starts from 0)\n  */\n  this.goToFrame = function(toFrame) {\n    if(toFrame < 0 || toFrame >= this.images.length) {\n      return;\n    }\n\n    // targetFrame gets used by the update() method to decide what frame to\n    // select next.  When it's not being used it gets set to -1.\n    targetFrame = toFrame;\n\n    if(targetFrame !== frame) {\n      this.playing = true;\n    }\n  };\n\n  /**\n  * Returns the current frame number.\n  *\n  * @method getFrame\n  * @return {Number} Current frame (starts from 0)\n  */\n  this.getFrame = function() {\n    return frame;\n  };\n\n  /**\n  * Returns the last frame number.\n  *\n  * @method getLastFrame\n  * @return {Number} Last frame number (starts from 0)\n  */\n  this.getLastFrame = function() {\n    return this.images.length-1;\n  };\n\n  /**\n  * Returns the current frame image as p5.Image.\n  *\n  * @method getFrameImage\n  * @return {p5.Image} Current frame image\n  */\n  this.getFrameImage = function() {\n    return this.images[frame];\n  };\n\n  /**\n  * Returns the frame image at the specified frame number.\n  *\n  * @method getImageAt\n  * @param {Number} frame Frame number\n  * @return {p5.Image} Frame image\n  */\n  this.getImageAt = function(f) {\n    return this.images[f];\n  };\n\n  /**\n  * Returns the current frame width in pixels.\n  * If there is no image loaded, returns 1.\n  *\n  * @method getWidth\n  * @return {Number} Frame width\n  */\n  this.getWidth = function() {\n    if (this.images[frame] instanceof p5.Image) {\n      return this.images[frame].width;\n    } else if (this.images[frame]) {\n      // Special case: Animation-from-spritesheet treats its images array differently.\n      return this.images[frame].frame.width;\n    } else {\n      return 1;\n    }\n  };\n\n  /**\n  * Returns the current frame height in pixels.\n  * If there is no image loaded, returns 1.\n  *\n  * @method getHeight\n  * @return {Number} Frame height\n  */\n  this.getHeight = function() {\n    if (this.images[frame] instanceof p5.Image) {\n      return this.images[frame].height;\n    } else if (this.images[frame]) {\n      // Special case: Animation-from-spritesheet treats its images array differently.\n      return this.images[frame].frame.height;\n    } else {\n      return 1;\n    }\n  };\n\n}\n\ndefineLazyP5Property('Animation', boundConstructorFactory(Animation));\n\n/**\n * Represents a sprite sheet and all it's frames.  To be used with Animation,\n * or static drawing single frames.\n *\n *  There are two different ways to load a SpriteSheet\n *\n * 1. Given width, height that will be used for every frame and the\n *    number of frames to cycle through. The sprite sheet must have a\n *    uniform grid with consistent rows and columns.\n *\n * 2. Given an array of frame objects that define the position and\n *    dimensions of each frame.  This is Flexible because you can use\n *    sprite sheets that don't have uniform rows and columns.\n *\n * @example\n *     // Method 1 - Using width, height for each frame and number of frames\n *     explode_sprite_sheet = loadSpriteSheet('assets/explode_sprite_sheet.png', 171, 158, 11);\n *\n *     // Method 2 - Using an array of objects that define each frame\n *     var player_frames = loadJSON('assets/tiles.json');\n *     player_sprite_sheet = loadSpriteSheet('assets/player_spritesheet.png', player_frames);\n *\n * @class SpriteSheet\n * @constructor\n * @param image String image path or p5.Image object\n */\nfunction SpriteSheet(pInst) {\n  var spriteSheetArgs = Array.prototype.slice.call(arguments, 1);\n\n  this.image = null;\n  this.frames = [];\n  this.frame_width = 0;\n  this.frame_height = 0;\n  this.num_frames = 0;\n\n  /**\n   * Generate the frames data for this sprite sheet baesd on user params\n   * @private\n   * @method _generateSheetFrames\n   */\n  this._generateSheetFrames = function() {\n    var sX = 0, sY = 0;\n    for (var i = 0; i < this.num_frames; i++) {\n      this.frames.push(\n        {\n          'name': i,\n          'frame': {\n            'x': sX,\n            'y': sY,\n            'width': this.frame_width,\n            'height': this.frame_height\n          }\n        });\n      sX += this.frame_width;\n      if (sX >= this.image.width) {\n        sX = 0;\n        sY += this.frame_height;\n        if (sY >= this.image.height) {\n          sY = 0;\n        }\n      }\n    }\n  };\n\n  if (spriteSheetArgs.length === 2 && Array.isArray(spriteSheetArgs[1])) {\n    this.frames = spriteSheetArgs[1];\n    this.num_frames = this.frames.length;\n  } else if (spriteSheetArgs.length === 4 &&\n    (typeof spriteSheetArgs[1] === 'number') &&\n    (typeof spriteSheetArgs[2] === 'number') &&\n    (typeof spriteSheetArgs[3] === 'number')) {\n    this.frame_width = spriteSheetArgs[1];\n    this.frame_height = spriteSheetArgs[2];\n    this.num_frames = spriteSheetArgs[3];\n  }\n\n  if(spriteSheetArgs[0] instanceof p5.Image) {\n    this.image = spriteSheetArgs[0];\n    if (spriteSheetArgs.length === 4) {\n      this._generateSheetFrames();\n    }\n  } else {\n    if (spriteSheetArgs.length === 2) {\n      this.image = pInst.loadImage(spriteSheetArgs[0]);\n    } else if (spriteSheetArgs.length === 4) {\n      this.image = pInst.loadImage(spriteSheetArgs[0], this._generateSheetFrames.bind(this));\n    }\n  }\n\n  /**\n   * Draws a specific frame to the canvas.\n   * @param frame_name  Can either be a string name, or a numeric index.\n   * @param x   x position to draw the frame at\n   * @param y   y position to draw the frame at\n   * @param [width]   optional width to draw the frame\n   * @param [height]  optional height to draw the frame\n   * @method drawFrame\n   */\n  this.drawFrame = function(frame_name, x, y, width, height) {\n    var frameToDraw;\n    if (typeof frame_name === 'number') {\n      frameToDraw = this.frames[frame_name].frame;\n    } else {\n      for (var i = 0; i < this.frames.length; i++) {\n        if (this.frames[i].name === frame_name) {\n          frameToDraw = this.frames[i].frame;\n          break;\n        }\n      }\n    }\n    var dWidth = width || frameToDraw.width;\n    var dHeight = height || frameToDraw.height;\n    pInst.image(this.image, frameToDraw.x, frameToDraw.y,\n      frameToDraw.width, frameToDraw.height, x, y, dWidth, dHeight);\n  };\n\n  /**\n   * Objects are passed by reference so to have different sprites\n   * using the same animation you need to clone it.\n   *\n   * @method clone\n   * @return {SpriteSheet} A clone of the current SpriteSheet\n   */\n  this.clone = function() {\n    var myClone = new SpriteSheet(pInst); //empty\n\n    // Deep clone the frames by value not reference\n    for(var i = 0; i < this.frames.length; i++) {\n      var frame = this.frames[i].frame;\n      var cloneFrame = {\n        'name':frame.name,\n        'frame': {\n          'x':frame.x,\n          'y':frame.y,\n          'width':frame.width,\n          'height':frame.height\n        }\n      };\n      myClone.frames.push(cloneFrame);\n    }\n\n    // clone other fields\n    myClone.image = this.image;\n    myClone.frame_width = this.frame_width;\n    myClone.frame_height = this.frame_height;\n    myClone.num_frames = this.num_frames;\n\n    return myClone;\n  };\n}\n\ndefineLazyP5Property('SpriteSheet', boundConstructorFactory(SpriteSheet));\n\n//general constructor to be able to feed arguments as array\nfunction construct(constructor, args) {\n  function F() {\n    return constructor.apply(this, args);\n  }\n  F.prototype = constructor.prototype;\n  return new F();\n}\n\n\n\n\n\n/*\n * Javascript Quadtree\n * based on\n * https://github.com/timohausmann/quadtree-js/\n * Copyright  2012 Timo Hausmann\n*/\n\nfunction Quadtree( bounds, max_objects, max_levels, level ) {\n\n  this.active = true;\n  this.max_objects\t= max_objects || 10;\n  this.max_levels\t\t= max_levels || 4;\n\n  this.level \t\t\t= level || 0;\n  this.bounds \t\t= bounds;\n\n  this.objects \t\t= [];\n  this.object_refs\t= [];\n  this.nodes \t\t\t= [];\n}\n\nQuadtree.prototype.updateBounds = function() {\n\n  //find maximum area\n  var objects = this.getAll();\n  var x = 10000;\n  var y = 10000;\n  var w = -10000;\n  var h = -10000;\n\n  for( var i=0; i < objects.length; i++ )\n    {\n      if(objects[i].position.x < x)\n        x = objects[i].position.x;\n      if(objects[i].position.y < y)\n        y = objects[i].position.y;\n      if(objects[i].position.x > w)\n        w = objects[i].position.x;\n      if(objects[i].position.y > h)\n        h = objects[i].position.y;\n    }\n\n\n  this.bounds = {\n    x:x,\n    y:y,\n    width:w,\n    height:h\n  };\n  //print(this.bounds);\n};\n\n/*\n\t * Split the node into 4 subnodes\n\t */\nQuadtree.prototype.split = function() {\n\n  var nextLevel\t= this.level + 1,\n      subWidth\t= Math.round( this.bounds.width / 2 ),\n      subHeight \t= Math.round( this.bounds.height / 2 ),\n      x \t\t\t= Math.round( this.bounds.x ),\n      y \t\t\t= Math.round( this.bounds.y );\n\n  //top right node\n  this.nodes[0] = new Quadtree({\n    x\t: x + subWidth,\n    y\t: y,\n    width\t: subWidth,\n    height\t: subHeight\n  }, this.max_objects, this.max_levels, nextLevel);\n\n  //top left node\n  this.nodes[1] = new Quadtree({\n    x\t: x,\n    y\t: y,\n    width\t: subWidth,\n    height\t: subHeight\n  }, this.max_objects, this.max_levels, nextLevel);\n\n  //bottom left node\n  this.nodes[2] = new Quadtree({\n    x\t: x,\n    y\t: y + subHeight,\n    width\t: subWidth,\n    height\t: subHeight\n  }, this.max_objects, this.max_levels, nextLevel);\n\n  //bottom right node\n  this.nodes[3] = new Quadtree({\n    x\t: x + subWidth,\n    y\t: y + subHeight,\n    width\t: subWidth,\n    height\t: subHeight\n  }, this.max_objects, this.max_levels, nextLevel);\n};\n\n\n/*\n\t * Determine the quadtrant for an area in this node\n\t */\nQuadtree.prototype.getIndex = function( pRect ) {\n  if(!pRect.collider)\n    return -1;\n  else\n  {\n    var index \t\t\t\t= -1,\n        verticalMidpoint \t= this.bounds.x + (this.bounds.width / 2),\n        horizontalMidpoint \t= this.bounds.y + (this.bounds.height / 2),\n\n        //pRect can completely fit within the top quadrants\n        topQuadrant = (pRect.collider.top() < horizontalMidpoint && pRect.collider.top() + pRect.collider.size().y < horizontalMidpoint),\n\n        //pRect can completely fit within the bottom quadrants\n        bottomQuadrant = (pRect.collider.top() > horizontalMidpoint);\n\n    //pRect can completely fit within the left quadrants\n    if( pRect.collider.left() < verticalMidpoint && pRect.collider.left() + pRect.collider.size().x < verticalMidpoint ) {\n      if( topQuadrant ) {\n        index = 1;\n      } else if( bottomQuadrant ) {\n        index = 2;\n      }\n\n      //pRect can completely fit within the right quadrants\n    } else if( pRect.collider.left() > verticalMidpoint ) {\n      if( topQuadrant ) {\n        index = 0;\n      } else if( bottomQuadrant ) {\n        index = 3;\n      }\n    }\n\n    return index;\n  }\n};\n\n\n/*\n\t * Insert an object into the node. If the node\n\t * exceeds the capacity, it will split and add all\n\t * objects to their corresponding subnodes.\n\t */\nQuadtree.prototype.insert = function( obj ) {\n  //avoid double insertion\n  if(this.objects.indexOf(obj) === -1)\n  {\n\n    var i = 0,\n        index;\n\n    //if we have subnodes ...\n    if( typeof this.nodes[0] !== 'undefined' ) {\n      index = this.getIndex( obj );\n\n      if( index !== -1 ) {\n        this.nodes[index].insert( obj );\n        return;\n      }\n    }\n\n    this.objects.push( obj );\n\n    if( this.objects.length > this.max_objects && this.level < this.max_levels ) {\n\n      //split if we don't already have subnodes\n      if( typeof this.nodes[0] === 'undefined' ) {\n        this.split();\n      }\n\n      //add all objects to there corresponding subnodes\n      while( i < this.objects.length ) {\n\n        index = this.getIndex( this.objects[i] );\n\n        if( index !== -1 ) {\n          this.nodes[index].insert( this.objects.splice(i, 1)[0] );\n        } else {\n          i = i + 1;\n        }\n      }\n    }\n  }\n};\n\n\n/*\n\t * Return all objects that could collide with a given area\n\t */\nQuadtree.prototype.retrieve = function( pRect ) {\n\n\n  var index = this.getIndex( pRect ),\n      returnObjects = this.objects;\n\n  //if we have subnodes ...\n  if( typeof this.nodes[0] !== 'undefined' ) {\n\n    //if pRect fits into a subnode ..\n    if( index !== -1 ) {\n      returnObjects = returnObjects.concat( this.nodes[index].retrieve( pRect ) );\n\n      //if pRect does not fit into a subnode, check it against all subnodes\n    } else {\n      for( var i=0; i < this.nodes.length; i=i+1 ) {\n        returnObjects = returnObjects.concat( this.nodes[i].retrieve( pRect ) );\n      }\n    }\n  }\n\n  return returnObjects;\n};\n\nQuadtree.prototype.retrieveFromGroup = function( pRect, group ) {\n\n  var results = [];\n  var candidates = this.retrieve(pRect);\n\n  for(var i=0; i<candidates.length; i++)\n    if(group.contains(candidates[i]))\n    results.push(candidates[i]);\n\n  return results;\n};\n\n/*\n\t * Get all objects stored in the quadtree\n\t */\nQuadtree.prototype.getAll = function() {\n\n  var objects = this.objects;\n\n  for( var i=0; i < this.nodes.length; i=i+1 ) {\n    objects = objects.concat( this.nodes[i].getAll() );\n  }\n\n  return objects;\n};\n\n\n/*\n\t * Get the node in which a certain object is stored\n\t */\nQuadtree.prototype.getObjectNode = function( obj ) {\n\n  var index;\n\n  //if there are no subnodes, object must be here\n  if( !this.nodes.length ) {\n\n    return this;\n\n  } else {\n\n    index = this.getIndex( obj );\n\n    //if the object does not fit into a subnode, it must be here\n    if( index === -1 ) {\n\n      return this;\n\n      //if it fits into a subnode, continue deeper search there\n    } else {\n      var node = this.nodes[index].getObjectNode( obj );\n      if( node ) return node;\n    }\n  }\n\n  return false;\n};\n\n\n/*\n\t * Removes a specific object from the quadtree\n\t * Does not delete empty subnodes. See cleanup-function\n\t */\nQuadtree.prototype.removeObject = function( obj ) {\n\n  var node = this.getObjectNode( obj ),\n      index = node.objects.indexOf( obj );\n\n  if( index === -1 ) return false;\n\n  node.objects.splice( index, 1);\n};\n\n\n/*\n\t * Clear the quadtree and delete all objects\n\t */\nQuadtree.prototype.clear = function() {\n\n  this.objects = [];\n\n  if( !this.nodes.length ) return;\n\n  for( var i=0; i < this.nodes.length; i=i+1 ) {\n\n    this.nodes[i].clear();\n  }\n\n  this.nodes = [];\n};\n\n\n/*\n\t * Clean up the quadtree\n\t * Like clear, but objects won't be deleted but re-inserted\n\t */\nQuadtree.prototype.cleanup = function() {\n\n  var objects = this.getAll();\n\n  this.clear();\n\n  for( var i=0; i < objects.length; i++ ) {\n    this.insert( objects[i] );\n  }\n};\n\n\n\nfunction updateTree() {\n  if(this.quadTree.active)\n  {\n    this.quadTree.updateBounds();\n    this.quadTree.cleanup();\n  }\n}\n\n//keyboard input\np5.prototype.registerMethod('pre', p5.prototype.readPresses);\n\n//automatic sprite update\np5.prototype.registerMethod('pre', p5.prototype.updateSprites);\n\n//quadtree update\np5.prototype.registerMethod('post', updateTree);\n\n//camera push and pop\np5.prototype.registerMethod('pre', cameraPush);\np5.prototype.registerMethod('post', cameraPop);\n\n//deltaTime\n//p5.prototype.registerMethod('pre', updateDelta);\n\n/**\n * Log a warning message to the host console, using native `console.warn`\n * if it is available but falling back on `console.log` if not.  If no\n * console is available, this method will fail silently.\n * @method _warn\n * @param {!string} message\n * @private\n */\np5.prototype._warn = function(message) {\n  var console = window.console;\n\n  if(console)\n  {\n    if('function' === typeof console.warn)\n    {\n      console.warn(message);\n    }\n    else if('function' === typeof console.log)\n    {\n      console.log('Warning: ' + message);\n    }\n  }\n};\n\n}));\n"]}